require("core/Constants")
local blessCurseManagerApi        = require("chaosbag/BlessCurseManagerApi")
local guidReferenceApi            = require("core/GUIDReferenceApi")
local mythosAreaApi               = require("mythos/MythosAreaApi")
local navigationOverlayApi        = require("core/NavigationOverlayApi")
local playAreaApi                 = require("playarea/PlayAreaApi")
local playermatApi                = require("playermat/PlayermatApi")
local searchLib                   = require("util/SearchLib")
local soundCubeApi                = require("core/SoundCubeApi")
local tokenArrangerApi            = require("tokens/TokenArrangerApi")
local tokenChecker                = require("tokens/TokenChecker")
local tokenSpawnTrackerApi        = require("tokens/TokenSpawnTrackerApi")
local zones                       = require("playermat/Zones")

---------------------------------------------------------
-- general setup
---------------------------------------------------------

-- wait ids for various functions
local waitIds                     = {}
local dynamicTokensPerCard        = {}

local chaosTokens                 = {}
local chaosTokensLastMatGUID      = nil

-- chaos token stat tracking
local tokenDrawingStats           = { ["Overall"] = {} }
local lastDrawnTokens             = {}
local autoFailMessages = {
  "<Name> has mastered the art of failure!",
  "The Auto-fail seems to have <Name>'s address.",
  "If there's an Auto-fail in the bag, <Name> will find it.",
  "Failure is <Name>'s best friend.",
  "The Auto-fail token loves <Name>—too much.",
  "It's official: <Name> is cursed!",
  "Nobody attracts disaster quite like <Name>.",
  "The Auto-fail just can't resist <Name>.",
  "<Name> is the patron saint of bad luck.",
  "Some call it bad luck, <Name> calls it <Day>.",
  "<Name> is the Auto-fail whisperer.",
  "<Name> is an Auto-fail magnet.",
  "Destiny has chosen <Name>... for failure.",
  "<Name> collects Auto-fails like they’re souvenirs.",
  "The Auto-fail token simply adores <Name>.",
  "Some call it unlucky, <Name> calls it a challenge.",
  "The chaos bag has a vendetta against <Name>.",
  "If failing were an art, <Name> would be a master painter.",
  "Auto-fails are like moths to <Name>'s flame.",
  "It's not bad luck—it’s a lifestyle for <Name>."
}

local elderSignMessages = {
  "<Name> is blessed by the elder gods!",
  "Luck flows through <Name>'s veins.",
  "<Name> is the chosen one!",
  "When there's an Elder Sign to draw, <Name> delivers.",
  "Fate smiles upon <Name>.",
  "<Name> is a certified miracle worker.",
  "The Elder Sign practically leaps into <Name>'s hand.",
  "All hail <Name>, master of fortune!",
  "<Name> bends luck to their will.",
  "Is <Name> lucky, or is it magic? Nobody knows.",
  "<Name> is the Elder Sign whisperer.",
  "<Name> is the luckiest investigator in Arkham.",
  "Providence shines upon <Name>. Truly inspiring!",
  "<Name> might as well own the Elder Sign.",
  "The Elder Sign knows exactly where <Name> is.",
  "When <Name> plays, the Elder Sign is a sure thing.",
  "With <Name> in the group, victory is inevitable.",
  "Chaos itself bows to <Name>'s luck.",
  "<Name>'s touch turns chaos into triumph.",
  "Elder Signs follow <Name> like moths to a flame."
}

local dualMessages = {
  "<Name> is the embodiment of extreme luck—both good and bad!",
  "No one has soared so high and fallen so hard as <Name>.",
  "Fate can’t decide what to do with <Name>—miracle one moment, disaster the next!",
  "<Name> has been both the chosen one and the forsaken one.",
  "No player has ever been as blessed and as cursed as <Name>.",
  "<Name> is a walking paradox: the luckiest and unluckiest at the same time.",
  "When <Name> wins, they *win big*. When they lose… well, you get the idea.",
  "The chaos bag giveth, and the chaos bag taketh away—just ask <Name>.",
  "<Name> has been on the wildest ride of fate ever seen in Arkham.",
  "The only constant in <Name>'s journey is unpredictability.",
  "Destiny can’t make up its mind about <Name>: ultimate triumph or crushing defeat?",
  "From utter devastation to legendary victories, <Name> has seen it all this game.",
  "<Name> is the luckiest unlucky player—or the unluckiest lucky player?",
  "The gods of chaos have taken a *special* interest in <Name> today.",
  "One moment, <Name> is a hero; the next, a tragic cautionary tale.",
  "If luck were a rollercoaster, <Name> just rode it with no safety bar.",
  "Arkham’s fate played favorites with <Name>—but kept changing its mind!",
  "Never before has someone been so blessed *and* so doomed as <Name>.",
  "<Name> defied the odds in *both* directions this game!",
  "Legend will speak of <Name>’s ridiculous streak of fortune *and* disaster."
}


local bagSearchers                = {}
local lastZoneEnterObject         = nil

-- online functionality related variables
local library, requestObj, modMeta, searchFilter, authorFilter
local acknowledgedUpgradeVersions = {}
local authorList                  = {}
local contentToShow               = "campaign"
local currentListItem             = 1
local tabIdTable                  = {
  tab1 = "campaign",
  tab2 = "scenario",
  tab3 = "fanmade-campaign",
  tab4 = "fanmade-scenario",
  tab5 = "fanmade-playercards"
}

-- optionPanel data (intentionally not local!)
optionPanel                       = {}
local sentOptionPanelMessage      = {}
local LANGUAGES                   = {
  { code = "zh_CN", name = "简体中文" },
  { code = "zh_TW", name = "繁體中文" },
  { code = "de", name = "Deutsch" },
  { code = "en", name = "English" },
  { code = "es", name = "Español" },
  { code = "fr", name = "Français" },
  { code = "it", name = "Italiano" }
}
local RESOURCE_OPTIONS            = {
  "enabled",
  "custom",
  "disabled"
}

-- track player-specific visibilities
local actionTrackerVisibility     = {}
local blurseVisibility            = {}
local handVisibility              = {}

-- track cards' tokens
local cardTokens                  = {}
local cardSettings                = {}

---------------------------------------------------------
-- data for tokens
---------------------------------------------------------

TokenManager                      = {}
local tokenOffsets                = {}

-- Table of data extracted from the token source bag, keyed by the Memo on each token which
-- should match the token type keys ("resource", "clue", etc)
local tokenTemplates
local playerCardData, locationData

-- stateIDs for the multi-stated resource tokens
local stateTable                  = {
  ["resource"] = 1,
  ["ammo"]     = 2,
  ["bounty"]   = 3,
  ["charge"]   = 4,
  ["evidence"] = 5,
  ["secret"]   = 6,
  ["supply"]   = 7,
  ["offering"] = 8
}

---------------------------------------------------------
-- general code
---------------------------------------------------------

-- saving state of optionPanel to restore later
function onSave()
  local chaosTokensGUID = {}
  for _, obj in ipairs(chaosTokens) do
    if obj ~= nil then
      table.insert(chaosTokensGUID, obj.getGUID())
    end
  end

  return JSON.encode({
    acknowledgedUpgradeVersions = acknowledgedUpgradeVersions,
    actionTrackerVisibility     = actionTrackerVisibility,
    blurseVisibility            = blurseVisibility,
    chaosTokensLastMatGUID      = chaosTokensLastMatGUID,
    chaosTokensGUID             = chaosTokensGUID,
    handVisibility              = handVisibility,
    optionPanel                 = optionPanel
  })
end

function onLoad(savedData)
  if savedData and savedData ~= "" then
    local loadedData            = JSON.decode(savedData)
    acknowledgedUpgradeVersions = loadedData.acknowledgedUpgradeVersions
    actionTrackerVisibility     = loadedData.actionTrackerVisibility
    blurseVisibility            = loadedData.blurseVisibility
    chaosTokensLastMatGUID      = loadedData.chaosTokensLastMatGUID
    handVisibility              = loadedData.handVisibility
    optionPanel                 = loadedData.optionPanel

    -- restore saved state for drawn chaos tokens
    for _, guid in ipairs(loadedData.chaosTokensGUID or {}) do
      table.insert(chaosTokens, getObjectFromGUID(guid))
    end

    updateOptionPanelState()
  end

  for _, obj in ipairs(getObjects()) do
    onObjectSpawn(obj)
  end

  getModVersion()
  updateHandVisibility()
  updateBlurseVisibility()
  math.randomseed(os.time())
  TokenManager.initialize()

  -- add a button and context menu to the chaos token stat tracker
  local statTracker = guidReferenceApi.getObjectByOwnerAndType("Mythos", "StatTracker")
  if statTracker then
    statTracker.UI.setXmlTable({
      {
        tag = "Button",
        attributes = {
          onClick = "Global/handleStatTrackerClick",
          position = "0 0 -11",
          width = "135",
          height = "135",
          color = "#00000000"
        }
      }
    })
    statTracker.addContextMenuItem("Print my stats",
      function(playerColor) handleStatTrackerClick(Player[playerColor], "-3") end)
  end
  Wait.frames(createActionTrackerUI, 10)

  -- initialization of library (delay to let Navigation Overlay build)
  Wait.time(function()
    WebRequest.get(SOURCE_REPO .. 'library.json', libraryDownloadCallback)
  end, 1)

  -- load specific option panel state for debugging / developing
  if LOAD_DEBUG_OPTION_PANEL then
    Wait.frames(function() loadOptionPanelState(DEBUG_OPTION_PANEL_STATE) end, 90)
  end
end

-- provides a random seed (from 1 to 999) to be used by "linked" objects like the action tokens
function getRandomSeed()
  return math.random(999)
end

-- Event hook for any object search. When chaos tokens are manipulated while the chaos bag
-- container is being searched, a TTS bug can cause tokens to duplicate or vanish. We lock the
-- chaos bag during search operations to avoid this.
function onObjectSearchStart(object, playerColor)
  local chaosBag = findChaosBag()
  if object == chaosBag then
    bagSearchers[playerColor] = true
  end
end

-- Event hook for any object search. When chaos tokens are manipulated while the chaos bag
-- container is being searched, a TTS bug can cause tokens to duplicate or vanish. We lock the
-- chaos bag during search operations to avoid this.
function onObjectSearchEnd(object, playerColor)
  local chaosBag = findChaosBag()
  if object == chaosBag then
    bagSearchers[playerColor] = nil
  end
  Player[playerColor].clearSelectedObjects()
end

-- Pass object enter container events to the PlayArea to clear vector lines from dragged cards.
-- This requires the try method as cards won't exist any more after they enter a deck, so the lines
-- can't be cleared.
function tryObjectEnterContainer(container, object)
  -- stop mini cards from forming decks
  if object.hasTag("Minicard") and container.hasTag("Minicard") then
    return false
  elseif object.type == "Card" and object.getName() ~= "Atlach-Nacha" then
    handleTokenDetaching({ card = object })
  end

  playAreaApi.tryObjectEnterContainer(container, object)
  return true
end

-- TTS event for objects that enter zones
function onObjectEnterZone(zone, object)
  if lastZoneEnterObject == object then return end
  lastZoneEnterObject = object
  Wait.frames(function() lastZoneEnterObject = nil end, 3)

  -- detect the "token discard zones" beneath the hand zones
  if zone.getName() == "TokenDiscardZone" then
    if object.type == "Card" then
      local attachments = object.getAttachments()
      if not attachments then return end

      local matcolor = playermatApi.getMatColorByPosition(object.getPosition())
      local trash    = guidReferenceApi.getObjectByOwnerAndType(matcolor, "Trash")

      for i = #attachments, 1, -1 do
        local deepObj = attachments[i]
        if not tokenChecker.isChaosTokenName(deepObj["nickname"]) and deepObj["memo"] ~= nil then
          trash.putObject(object.removeAttachment(deepObj["index"]))
        end
      end
    elseif object.type == "Tile" and not tokenChecker.isChaosToken(object) and object.getMemo() and
        not object.getLock() and object.interactable == true then
      local matcolor = playermatApi.getMatColorByPosition(object.getPosition())
      local trash    = guidReferenceApi.getObjectByOwnerAndType(matcolor, "Trash")
      trash.putObject(object)
    end
  elseif zone.type == "Hand" and object.type == "Card" then
    -- make sure the card is face-up
    if object.is_face_down then
      object.flip()
    end

    -- maybe reset data about sealed tokens (if that function exists)
    if object.hasTag("CardThatSeals") then
      local func = object.getVar("resetSealedTokens")
      if func ~= nil then
        object.call("resetSealedTokens")
      end
    end

    -- maybe disable card helpers
    if object.hasTag("CardWithHelper") then
      local func = object.getVar("setHelperState")
      if func ~= nil then
        object.call("setHelperState", false)
      end
    end

    applyHidingToCard(object, zone.getValue())
  end
end

-- TTS event for objects that leave zones
function onObjectLeaveZone(zone, object)
  -- end here if one of the objects doesn't exist
  if zone.isDestroyed() or object.isDestroyed() then return end

  -- make sure that the object really left and isn't still in a hand zone
  for _, objZone in ipairs(object.getZones()) do
    if objZone.isDestroyed() or objZone.type == "Hand" then return end
  end

  -- make object visible
  object.setHiddenFrom({})
end

-- handle card drawing via number typing for multihanded gameplay
-- (and additionally allow Norman Withers to draw multiple cards via number)
function onObjectNumberTyped(hoveredObject, playerColor, number)
  -- adds cards to appropriate hand for Attachment Helper
  if hoveredObject.getName() == "Attachment Helper" then
    local matColor = playermatApi.getMatColorByPosition(hoveredObject.getPosition())
    local handColor = playermatApi.getPlayerColor(matColor)
    hoveredObject.deal(number, handColor)
    return true
  end

  -- only continue for decks or cards
  if hoveredObject.type ~= "Deck" and hoveredObject.type ~= "Card" then return end

  -- check if this is a card with states (and then change state instead of drawing it)
  local states = hoveredObject.getStates()
  if states ~= nil and #states > 0 then
    local stateId = hoveredObject.getStateId()
    if stateId ~= number and (#states + 1) >= number then
      hoveredObject.setState(number)
      return true
    end
  end

  -- check whether the hovered object is part of a players draw objects
  for color, _ in pairs(guidReferenceApi.getObjectsByType("Playermat")) do
    local deckAreaObjects = playermatApi.getDeckAreaObjects(color)
    if deckAreaObjects.topCard == hoveredObject or deckAreaObjects.draw == hoveredObject then
      playermatApi.drawCardsWithReshuffle(color, number)
      return true
    end
  end
end

function onPlayerAction(player, action, targets)
  if action == Player.Action.Delete then
    if player.admin then
      for _, target in ipairs(targets) do
        maybeUpdateActionTrackerTokens(target, 5)
      end
    else
      -- disable delete action (only applies to promoted players) and discard objects instead
      for _, target in ipairs(targets) do
        local matColor = playermatApi.getMatColorByPosition(target.getPosition())
        local trash = guidReferenceApi.getObjectByOwnerAndType(matColor, "Trash")

        maybeUpdateActionTrackerTokens(target, 20)

        trash.putObject(target)
      end
      return false
    end
  elseif action == Player.Action.PickUp then
    -- attach tokens to each card -> might need to add a limit if performance is an issue
    for _, target in ipairs(targets) do
      if target.type == "Card" and not target.hasTag("Minicard") then
        handleTokenAttaching({ player = player, card = target })
      end
    end
  end
end

function onPlayerChangeColor()
  Wait.frames(function()
    -- updates the displayed names in the action tracker
    for matColor, _ in pairs(guidReferenceApi.getObjectsByType("Playermat")) do
      updateActionTrackerName(matColor)
    end
  end, 1)
end

function onObjectRotate(obj, _, flip, _, _, oldFlip)
  if flip == oldFlip then return end

  if obj.hasTag("Minicard") then
    for matColor, _ in pairs(guidReferenceApi.getObjectsByType("Playermat")) do
      Wait.frames(function() updateActionTrackerName(matColor) end, 50)
    end
  else
    maybeUpdateActionTrackerTokens(obj, 50)
  end
end

function onObjectSpawn(obj)
  if obj.hasTag("NotInteractable") then
    obj.interactable = false
  end

  if obj.hasTag("DoomCounter_ignore") then
    obj.highlightOn({ 0.67, 0.11, 0 })
  end

  if obj.hasTag("Temporary") then
    obj.highlightOn({ 0, 0.7843, 0.7843 })
  end

  if obj.hasTag("Reloadable") then
    obj.addContextMenuItem("Redownload this", function(playerColor)
      placeholder_download({ filename = obj.getGMNotes(), player = Player[playerColor], replace = obj.getGUID() })
    end)
  end

  maybeUpdateActionTrackerTokens(obj, 5)
end

function onObjectDrop(playerColor, obj)
  if obj.hasTag("Minicard") then
    for _, card in ipairs(searchLib.belowPosition(obj.getPosition(), "isCard")) do
      local md = JSON.decode(card.getGMNotes()) or {}
      if md.type == "Investigator" and (md.id or md.TtsZoopGuid) then
        local miniMd = JSON.decode(obj.getGMNotes()) or {}
        miniMd.type = "Minicard"
        miniMd.id = (md.id or md.TtsZoopGuid) .. "-m"
        obj.setGMNotes(JSON.encode_pretty(miniMd))
        printToColor("Updated minicard ID to match investigator", playerColor, "Green")
      end
    end
  elseif obj.getMemo() == "dynamic" then
    -- handle dynamic tokens being dropped
    local searchResult = searchLib.belowPosition(obj.getPosition(), "isCard")
    if #searchResult == 0 then return end

    -- track dynamic tokens per card
    local card = searchResult[1]
    local cardGuid = card.getGUID()
    dynamicTokensPerCard[card] = dynamicTokensPerCard[card] or {}
    table.insert(dynamicTokensPerCard[card], obj)

    -- make sure it can't be dropped again
    obj.interactable = false

    if waitIds["addToken" .. cardGuid] then
      Wait.stop(waitIds["addToken" .. cardGuid])
    end

    -- spawn matching tokens after a delay
    waitIds["addToken" .. cardGuid] = Wait.time(function()
      if card ~= nil then
        local result = TokenManager.addUseToCard({ card = card, useType = "resource", additionalCount = #dynamicTokensPerCard[card] })
        for _, token in ipairs(dynamicTokensPerCard[card]) do
          if token ~= nil then
            if result == true then
              token.destruct()
            else
              obj.interactable = true
            end
          end
        end
      end
      dynamicTokensPerCard[card] = nil
      waitIds["addToken" .. cardGuid] = nil
    end, 0.3)
  else
    maybeUpdateActionTrackerTokens(obj, 20)
  end
end

function onObjectPickUp(_, object)
  stopTokenTransformUpdating(object)
end

function maybeUpdateActionTrackerTokens(obj, delayFrames)
  if obj == nil or obj.isDestroyed() or not obj.hasTag("UniversalToken") then return end
  local owner = guidReferenceApi.getOwnerOfObject(obj)
  if owner == "Mythos" then return end
  updateActionTrackerTokens(owner, delayFrames)
end

---------------------------------------------------------
-- chaos token drawing
---------------------------------------------------------

-- checks scripting zone for chaos bag (also called by a lot of objects!)
function findChaosBag()
  local chaosBagZone = guidReferenceApi.getObjectByOwnerAndType("Mythos", "ChaosBagZone")

  -- error handling: scripting zone not found
  if chaosBagZone == nil then
    printToAll("Zone for chaos bag detection couldn't be found.", "Red")
    return
  end

  for _, item in ipairs(chaosBagZone.getObjects()) do
    if item.getDescription() == "Chaos Bag" then
      return item
    end
  end

  -- error handling: chaos bag not found
  printToAll("Chaos bag couldn't be found.", "Red")
end

-- returns all chaos tokens to the bag
function returnChaosTokens()
  local chaosBag = findChaosBag()
  for _, token in pairs(chaosTokens) do
    if token ~= nil then
      token.memo = nil
      token.destroyAttachments()
      chaosBag.putObject(token)
    end
  end
  chaosTokens = {}
  isTokenXMLActive = false
end

-- returns a single chaos token to the bag and calls respective functions
function returnChaosTokenToBag(params)
  local name = params.token.getName()
  local chaosBag = findChaosBag()
  params.token.memo = nil
  params.token.destroyAttachments()
  chaosBag.putObject(params.token)
  tokenArrangerApi.layout()
  if name == "Bless" or name == "Curse" then
    blessCurseManagerApi.releasedToken(name, params.token.getGUID(), params.fromBag)
  end
end

-- returns the index of a token in the chaosTokens table
function getTokenIndex(token)
  for i, obj in ipairs(chaosTokens) do
    if obj == token then
      return i
    end
  end
end

-- starts a redraw effect and displays buttons for a choice if needed
function activeRedrawEffect(params)
  redrawData = params

  if isTokenXMLActive == true then
    broadcastToAll("Clear already active buttons first, then try again", "Red")
    return
  end

  if #chaosTokens == 0 then
    broadcastToAll("No tokens found in play area", "Red")
    return
  end

  -- nil handling
  redrawData.validTokens = redrawData.validTokens or {}
  redrawData.invalidTokens = redrawData.invalidTokens or {}

  -- determine if only some tokens are able to be returned to the bag
  local matchingTokensInPlay = {}
  for _, token in ipairs(chaosTokens) do
    if token.memo ~= nil then
      tokenName = token.memo
    else
      tokenName = getReadableTokenName(token.getName())
    end

    -- allow valid tokens or not invalid tokens, also allow any token if both lists empty
    if (redrawData.validTokens[tokenName] ~= nil and isTableEmpty(redrawData.invalidTokens)) or
        (isTableEmpty(redrawData.validTokens) and not redrawData.invalidTokens[tokenName]) or
        (isTableEmpty(redrawData.validTokens) and isTableEmpty(redrawData.invalidTokens)) then
      table.insert(matchingTokensInPlay, token)
    end
  end

  -- proceed according to number of matching tokens
  if #matchingTokensInPlay == 0 then
    broadcastToAll("No eligible token found in play area", "Red")
  elseif #matchingTokensInPlay == 1 then
    returnAndRedraw(_, matchingTokensInPlay[1].getGUID())
  else
    -- draw XML to allow choosing the token to return to bag
    isTokenXMLActive = true
    for _, token in ipairs(matchingTokensInPlay) do
      token.UI.setXmlTable({
        {
          tag = "VerticalLayout",
          attributes = {
            height = 275,
            width = 275,
            padding = "0 0 20 25",
            scale = "0.4 0.4 1",
            rotation = "0 0 180",
            position = "0 0 -15",
            color = "rgba(0,0,0,0.7)",
            onClick = "Global/returnAndRedraw(" .. token.getGUID() .. ")",
          },
          children = {
            {
              tag = "Text",
              attributes = {
                fontSize = "100",
                font = "font_teutonic-arkham",
                color = "#ffffff",
                text = "Redraw"
              }
            },
            {
              tag = "Text",
              attributes = {
                fontSize = "125",
                font = "font_arkhamicons",
                color = "#ffffff",
                text = "u"
              }
            }
          }
        }
      })
    end
  end
end

-- returns a chaos token to the chaos bag and redraws another
function returnAndRedraw(_, tokenGUID)
  local returnedToken = getObjectFromGUID(tokenGUID)
  local tokenName = returnedToken.getName()
  local indexOfReturnedToken = getTokenIndex(returnedToken)
  local matColor = playermatApi.getMatColorByPosition(returnedToken.getPosition())
  local mat = guidReferenceApi.getObjectByOwnerAndType(matColor, "Playermat")

  local takeParameters = {
    position = returnedToken.getPosition(),
    rotation = returnedToken.getRotation()
  }

  if #chaosTokens > indexOfReturnedToken then
    takeParameters.rotation = takeParameters.rotation + Vector(0, 0, -8)
  end

  -- perform the actual token replacing
  trackChaosToken(tokenName, mat.getMemo(), true)
  local params = { token = returnedToken, fromBag = true }
  returnChaosTokenToBag(params)

  -- remove XML from tokens in play
  isTokenXMLActive = false
  for _, token in ipairs(chaosTokens) do
    token.UI.setXml("")
  end

  chaosTokens[indexOfReturnedToken] = drawChaosToken({
    mat = mat,
    drawAdditional = true,
    tokenType = redrawData.drawSpecificToken, -- currently only used for Nkosi Mabati
    takeParameters = takeParameters
  })

  -- remove these tokens from the bag
  if redrawData.returnToPool then
    -- let the bless/curse manager handle these
    if tokenName == "Bless" or tokenName == "Curse" then
      blessCurseManagerApi.removeToken(tokenName)
    else
      local invertedTable = createChaosTokenNameLookupTable()
      removeChaosToken(invertedTable[tokenName])
    end
  end

  redrawData = {}

  -- return a reference to the freshly drawn token
  return chaosTokens[indexOfReturnedToken]
end

-- Checks to see if the chaos bag can be manipulated. If a player is searching the bag when tokens
-- are drawn or replaced a TTS bug can cause those tokens to vanish. Any functions which change the
-- contents of the bag should check this method before doing so.
-- This method will broadcast a message to all players if the bag is being searched.
---@return boolean: True if the bag is manipulated, false if it should be blocked.
function canTouchChaosTokens()
  for _, searching in pairs(bagSearchers) do
    if searching then
      broadcastToAll("Someone is searching the chaos bag, can't touch the tokens.", "Red")
      return false
    end
  end
  return true
end

-- converts the human readable name to the empty name that the bag uses
function getChaosTokenName(tokenName)
  if tokenName == "Custom Token" then
    tokenName = ""
  end
  return tokenName
end

-- converts the empty name to the human readable name
function getReadableTokenName(tokenName)
  if tokenName == "" then
    tokenName = "Custom Token"
  end
  return tokenName
end

-- called by playermats (by the "Draw chaos token" button)
function drawChaosToken(params)
  if not canTouchChaosTokens() then return end

  local matGUID = params.mat.getGUID()

  -- return token(s) on other playermat first
  if chaosTokensLastMatGUID ~= nil and chaosTokensLastMatGUID ~= matGUID and #chaosTokens ~= 0 then
    returnChaosTokens()
    chaosTokensLastMatGUID = nil
    return
  end

  chaosTokensLastMatGUID = matGUID

  -- if we have left clicked and have no tokens OR if we have right clicked
  if params.drawAdditional or #chaosTokens == 0 then
    local chaosBag = findChaosBag()
    if #chaosBag.getObjects() == 0 then return end
    chaosBag.shuffle()

    -- add the token to the list, compute new position based on list length
    local tokenOffset = Vector(-1.55 + 0.17 * #chaosTokens, 0.25, -0.58)

    -- slightly rotate subsequent chaos tokens
    local tokenRotZ = 0
    if #chaosTokens > 0 then
      tokenRotZ = 354.5
    end

    local takeParameters = params.takeParameters or {}
    takeParameters.position = takeParameters.position or params.mat.positionToWorld(tokenOffset)
    takeParameters.rotation = takeParameters.rotation or params.mat.getRotation():setAt("z", tokenRotZ)

    local token
    if params.guidToBeResolved then
      -- resolve a sealed token from a card
      token = getObjectFromGUID(params.guidToBeResolved)
      token.setPositionSmooth(takeParameters.position)
      tokenArrangerApi.layout()

      local tokenName = token.getName()
      if tokenName == "Bless" or tokenName == "Curse" then
        blessCurseManagerApi.releasedToken(tokenName, token.getGUID())
      end
    else
      -- take a token from the bag, either specified or random
      if params.tokenType then
        for i, lookedForToken in ipairs(chaosBag.getObjects()) do
          if lookedForToken.nickname == params.tokenType then
            takeParameters.index = i - 1
          end
        end
      end
      token = chaosBag.takeObject(takeParameters)
    end

    -- get data for token description
    local name = token.getName()
        
    if name == "Bless" or name == "Curse" then
      local isLuckyPennyEnabled = params.mat.getVar("luckyPennyEnabled")
      if isLuckyPennyEnabled then
        token.UI.setXmlTable({
          {
            tag = "Panel",
            attributes = {
              height = 275,
              width = 275,
              scale = "0.4 0.4 1",
              rotation = "0 0 180",
              position = "0 0 -15",
              color = "rgba(0,0,0,0.7)"
            },
            children = {
              {
                tag = "Text",
                attributes = {
                  font = "font_arkhamicons",
                  onClick = "Global/luckyPenny(" .. token.getGUID() .. ")",
                  text = "zy",
                  color = "White",
                  fontSize = "125"
                }
              }
            }
          }
        })
      end
    end

    local tokenData = mythosAreaApi.returnTokenData().tokenData or {}
    local specificData = tokenData[name] or {}
    token.setDescription(specificData.description or "")
    trackChaosToken(name, params.mat.getMemo())

    if not params.takeParameters then
      table.insert(chaosTokens, token)
    end
    return token
  else
    returnChaosTokens()
  end
end

function luckyPenny(_, tokenGUID)
  local blurseToken = getObjectFromGUID(tokenGUID)

  local coinFlip = math.random(2)
  if coinFlip == 1 then
    blurseToken.memo = "Bless"
  else
    blurseToken.memo = "Curse"
  end
  local pos = blurseToken.getPosition() + Vector(1.35, 0.1, 0)
  local id = blurseToken.memo:lower()
  local url = ID_URL_MAP[id].url or ""

  if url ~= "" then
    spawnObject({
      type = 'Custom_Tile',
      position = pos,
      scale = { 0.5, 1.0, 0.5 },
      rotation = { 0, 270, 0 },
      callback_function = function(obj)
        blurseToken.UI.setXml("")
        blurseToken.addAttachment(obj)
      end
    }).setCustomObject({
      type = 2,
      image = url,
      thickness = 0.1
    })
  end
end

---------------------------------------------------------
-- token spawning
---------------------------------------------------------

-- DEPRECATED. Use TokenManager instead --> TODO: Remove this with the new downloads repo (v.4.0.0)
-- Spawns a single token.
---@param params table Array with arguments to the method. 1 = position, 2 = type, 3 = rotation
function spawnToken(params)
  return TokenManager.spawnToken({
    position = params[1],
    tokenType = params[2],
    rotation = params[3]
  })
end

---------------------------------------------------------
-- chaos token stat tracker
---------------------------------------------------------

function trackChaosToken(tokenName, matColor, subtract)
  -- initialize tables
  if not tokenDrawingStats[matColor] then tokenDrawingStats[matColor] = {} end

  -- increase stats by 1 (or decrease if token is returned)
  local modifier                          = (subtract and -1 or 1)
  tokenName                               = getReadableTokenName(tokenName)
  tokenDrawingStats["Overall"][tokenName] = (tokenDrawingStats["Overall"][tokenName] or 0) + modifier
  tokenDrawingStats[matColor][tokenName]  = (tokenDrawingStats[matColor][tokenName] or 0) + modifier

  -- add to list of last drawn tokens (if not subtracting)
  if not subtract then
    table.insert(lastDrawnTokens, { tokenName = tokenName, matColor = matColor })
    if #lastDrawnTokens > 5 then
      table.remove(lastDrawnTokens, 1)
    end
  end
end

-- Left-click: print stats, Right-click: reset stats
function handleStatTrackerClick(player, clickType, _)
  if clickType == "-2" then
    -- right-clicked
    resetChaosTokenStatTracker(player)
    return
  end

  local mostAutoFails, mostElderSigns = "Nobody", "Nobody"
  local maxAutoFails, maxElderSigns   = 0, 0
  local foundAnyStats                 = false

  for matColor, personalStats in pairs(tokenDrawingStats) do
    -- skip if middle-clicked and not the color of the clicking player
    if clickType ~= "-3" or matColor == playermatApi.getMatColor(player.color) then
      local playerColor, playerName

      if matColor == "Overall" then
        playerColor = "White"
        playerName  = "Overall"
      else
        playerColor = playermatApi.getPlayerColor(matColor)
        playerName  = Player[playerColor].steam_name or playerColor

        -- track auto-fails / elder signs
        if (personalStats["Auto-fail"] or 0) > maxAutoFails then
          mostAutoFails = playerColor
          maxAutoFails  = personalStats["Auto-fail"]
        end

        if (personalStats["Elder Sign"] or 0) > maxElderSigns then
          mostElderSigns = playerColor
          maxElderSigns  = personalStats["Elder Sign"]
        end
      end

      -- get the total count of drawn tokens for the player
      local totalCount = 0
      for _, value in pairs(personalStats) do
        totalCount = totalCount + value
      end

      -- only print the personal stats if any tokens were drawn
      if totalCount > 0 then
        foundAnyStats = true
        printToAll("------------------------------")
        printToAll(playerName .. " Stats", playerColor)

        -- print stats in order of the "ID_URL_MAP"
        for _, subtable in pairs(ID_URL_MAP) do
          local tokenName = subtable.name
          local value = personalStats[tokenName]
          if value and value ~= 0 then
            printToAll(tokenName .. ': ' .. tostring(value))
          end
        end

        -- also print stats for custom tokens
        local customTokenName = getReadableTokenName("")
        local customTokenCount = personalStats[customTokenName]
        if customTokenCount and customTokenCount ~= 0 then
          printToAll(customTokenName .. ': ' .. tostring(customTokenCount))
        end

        printToAll('Total: ' .. tostring(totalCount))
      end
    end
  end

  -- detect if any player drew tokens
  if foundAnyStats then
    -- end here if middle-clicked
    if clickType == "-3" then return end

    printToAll("------------------------------")

    -- maybe print history for last 5 token draws
    if #lastDrawnTokens > 0 then
      local tokenStr = ""
      for _, data in ipairs(lastDrawnTokens) do
        local handColor = playermatApi.getPlayerColor(data.matColor)
        local tokenName = data.tokenName
        if handColor ~= nil then
          tokenName = "[" .. Color.fromString(handColor):toHex() .. "]" .. tokenName .. "[-]"
        end
        tokenStr = tokenStr .. tokenName .. ", "
      end

      -- remove last delimiter
      tokenStr = string.sub(tokenStr, 1, -3)
      printToAll("Last 5 (old to new): " .. tokenStr)
    end

    -- print the player with the most auto-fails / elder signs
    if mostAutoFails == mostElderSigns then
      outputRandomMessage(mostAutoFails, dualMessages, { r = 200 / 255, g = 100 / 255, b = 255 / 255 })
    else
      outputRandomMessage(mostAutoFails, autoFailMessages, { r = 215 / 255, g = 30 / 255, b = 60 / 255 })
      outputRandomMessage(mostElderSigns, elderSignMessages, { r = 30 / 255, g = 185 / 255, b = 215 / 255 })
    end
  else
    printToAll("No tokens have been drawn yet.", "Yellow")
  end
end

function outputRandomMessage(playerColor, list, msgColor)
  if playerColor == "Nobody" then return end
  local playerName = getColoredName(playerColor)
  printToAll(list[math.random(#list)]:gsub("<Name>", playerName):gsub("<Day>", os.date("%A")), msgColor)
end

-- resets the count for each token to 0
function resetChaosTokenStatTracker(player)
  player.showConfirmDialog("Are you sure you want to reset the Chaos Token stats?",
    function()
      printToAll("Chaos Token stat tracker has been reset.")
      lastDrawnTokens = {}
      tokenDrawingStats = { ["Overall"] = {} }
    end
  )
end

---------------------------------------------------------
-- Difficulty selector script
---------------------------------------------------------

-- called for button creation on the difficulty selectors
---@param args table Parameters for this function:
-- object   TTSObject   Usually "self"
-- key      String      Name of the scenario
function createSetupButtons(args)
  local data = getDataValue('modeData', args.key)
  if data ~= nil then
    local buttonParameters          = {}
    buttonParameters.function_owner = args.object
    buttonParameters.position       = { 0, 0.1, -0.15 }
    buttonParameters.scale          = { 0.47, 1, 0.47 }
    buttonParameters.height         = 200
    buttonParameters.width          = 1150
    buttonParameters.color          = { 0.87, 0.8, 0.7 }

    if data.easy ~= nil then
      buttonParameters.label = "Easy"
      buttonParameters.click_function = "easyClick"
      args.object.createButton(buttonParameters)
      buttonParameters.position[3] = buttonParameters.position[3] + 0.20
    end

    if data.normal ~= nil then
      buttonParameters.label = "Standard"
      buttonParameters.click_function = "normalClick"
      args.object.createButton(buttonParameters)
      buttonParameters.position[3] = buttonParameters.position[3] + 0.20
    end

    if data.hard ~= nil then
      buttonParameters.label = "Hard"
      buttonParameters.click_function = "hardClick"
      args.object.createButton(buttonParameters)
      buttonParameters.position[3] = buttonParameters.position[3] + 0.20
    end

    if data.expert ~= nil then
      buttonParameters.label = "Expert"
      buttonParameters.click_function = "expertClick"
      args.object.createButton(buttonParameters)
      buttonParameters.position[3] = buttonParameters.position[3] + 0.20
    end

    if data.standalone ~= nil then
      buttonParameters.label = "Standalone"
      buttonParameters.click_function = "standaloneClick"
      args.object.createButton(buttonParameters)
    end
  end
end

-- called for adding chaos tokens
---@param args table Parameters for this function:
-- object object  Usually "self"
-- key    string  Name of the scenario
-- mode   string  difficulty (e.g. "hard" or "expert")
function fillContainer(args)
  local data = getDataValue('modeData', args.key)
  if data == nil then return end

  local value = data[args.mode]
  if value == nil or value.token == nil then return end

  local tokenList = {}

  for _, tokenId in ipairs(value.token) do
    table.insert(tokenList, tokenId)
  end

  if value.append ~= nil then
    for _, tokenId in ipairs(value.append) do
      table.insert(tokenList, tokenId)
    end
  end

  -- randomly choose tokens for specific Carcosa scenarios in standalone
  if value.random then
    local n = #value.random
    if n > 0 then
      for _, tokenId in ipairs(value.random[math.random(1, n)]) do
        table.insert(tokenList, tokenId)
      end
    end
  end

  setChaosBagState(tokenList)

  if value.message then
    broadcastToAll(value.message)
  end

  if value.warning then
    broadcastToAll(value.warning, { 1, 0.5, 0.5 })
  end
end

function getDataValue(storage, key)
  local DATA_HELPER = guidReferenceApi.getObjectByOwnerAndType("Mythos", "DataHelper")
  local data = DATA_HELPER.getTable(storage)
  if data ~= nil then
    local value = data[key]
    if value ~= nil then
      local res = {}
      for m, v in pairs(value) do
        res[m] = v
        if res[m].parent ~= nil then
          local parentData = getDataValue(storage, res[m].parent)
          if parentData ~= nil and parentData[m] ~= nil and parentData[m].token ~= nil then
            res[m].token = parentData[m].token
          end
          res[m].parent = nil
        end
      end
      return res
    end
  end
end

function createChaosTokenNameLookupTable()
  local namesToIds = {}
  for k, v in pairs(ID_URL_MAP) do
    namesToIds[v.name] = k
  end
  return namesToIds
end

-- returns the currently drawn chaos tokens
---@api ChaosBagApi
function getChaosTokensinPlay()
  return chaosTokens
end

-- returns a table of chaos token ids in the current chaos bag
---@api ChaosBag / ChaosBagApi
function getChaosBagState()
  local tokens = {}
  local invertedTable = createChaosTokenNameLookupTable()
  local chaosBag = findChaosBag()

  for _, v in ipairs(chaosBag.getObjects()) do
    local id = invertedTable[v.name]
    if id then
      table.insert(tokens, id)
    else
      printToAll(v.name .. " token not recognized. Will not be recorded.", "Yellow")
    end
  end

  return tokens
end

-- respawns the chaos bag with a new state of tokens
---@param tokenList table List of chaos token ids
---@api ChaosBag / ChaosBagApi
function setChaosBagState(tokenList)
  if not canTouchChaosTokens() then return end

  local chaosBag = findChaosBag()
  local chaosBagData = chaosBag.getData()
  local reserveData = getObjectFromGUID("106418").getData()
  local tokenCache = {}
  local containedObjects = {}

  -- create a temporary copy of the data for each chaos token
  for _, objData in ipairs(reserveData.ContainedObjects) do
    tokenCache[objData.Nickname] = objData
  end

  -- iterate over tokenlist and insert specified tokens into new table
  for _, tokenId in ipairs(tokenList) do
    local tokenName = ID_URL_MAP[tokenId].name
    table.insert(containedObjects, tokenCache[tokenName])
  end

  -- overwrite chaos bag content and respawn it
  chaosBagData.ContainedObjects = containedObjects
  chaosBag.destruct()
  spawnObjectData({ data = chaosBagData })

  -- remove tokens that are still in play
  for _, token in pairs(chaosTokens) do
    if token ~= nil then token.destruct() end
  end
  chaosTokens = {}
  chaosTokensLastMatGUID = nil

  -- reset bless / curse manager
  blessCurseManagerApi.removeTakenTokensAndReset()

  printToAll("Chaos Bag set to chosen difficulty.", "Green")
end

-- spawns the specified chaos token and puts it into the chaos bag
---@param id string ID of the chaos token
function spawnChaosToken(id)
  if not canTouchChaosTokens() then return end

  id = id:lower()
  local chaosBag = findChaosBag()
  local url = ID_URL_MAP[id].url or ""

  if url ~= "" then
    return spawnObject({
      type = 'Custom_Tile',
      position = { 0.49, 3, 0 },
      scale = { 0.81, 1.0, 0.81 },
      rotation = { 0, 270, 0 },
      callback_function = function(obj)
        obj.setName(ID_URL_MAP[id].name)
        chaosBag.putObject(obj)
        tokenArrangerApi.layout()
      end
    }).setCustomObject({
      type = 2,
      image = url,
      thickness = 0.1
    })
  end
end

-- removes the specified chaos token from the chaos bag
---@param id string ID of the chaos token
function removeChaosToken(id)
  if not canTouchChaosTokens() then return end

  local tokens = {}
  local chaosBag = findChaosBag()
  local name = ID_URL_MAP[id].name

  for _, v in ipairs(chaosBag.getObjects()) do
    if v.name == name then table.insert(tokens, v.guid) end
  end

  -- error handling: no matching token found
  if #tokens == 0 then
    printToAll("No " .. name .. " tokens in the chaos bag.", "Yellow")
    return
  end

  chaosBag.takeObject({
    guid = tokens[1],
    smooth = false,
    callback_function = function(obj)
      obj.destruct()
      tokenArrangerApi.layout()
    end
  })
  printToAll("Removing " .. name .. " token (in bag: " .. #tokens - 1 .. ")", "White")
end

-- returns all sealed tokens on cards to the chaos bag
function releaseAllSealedTokens(playerColor)
  for _, obj in ipairs(getObjectsWithTag("CardThatSeals")) do
    obj.call("releaseAllTokens", playerColor)
  end
end

---------------------------------------------------------
-- Content Importing and XML functions
---------------------------------------------------------

-- callback function for the search field in the download menu
function onSearchValueSubmit(_, value)
  -- this event seems to be called 5x at once, so we use this flag to just execute it once
  if ignoreSubmit then return end
  ignoreSubmit = true

  -- store input value in global var
  if value == "" then
    searchFilter = nil
  else
    searchFilter = value
  end

  -- update XML so that the settings persists
  UI.setAttribute("searchField", "text", value)

  -- turn off flag after 0.1s
  Wait.time(function() ignoreSubmit = false end, 0.1)

  -- update list (including new filter setting)
  updateDownloadItemList(true)
end

-- callback function for the "author" dropdown in the download menu
function onAuthorFilterChanged(_, value)
  -- store input value in global var
  if value == "All authors" then
    authorFilter = nil
  else
    authorFilter = value
  end

  -- update XML so that the settings persists
  UI.setAttribute("authorDropdown", "value", returnAuthorId(value))

  -- update list (including new filter setting)
  updateDownloadItemList(true)
end

-- helper function to get the ID of the dropdown selection
function returnAuthorId(name)
  for index, optionName in ipairs(authorList) do
    if optionName == name then
      return index
    end
  end
end

-- forwards the requested content type to the update function and sets highlight to clicked tab
---@param tabId string Id of the clicked tab
function onClick_tab(_, _, tabId)
  for listId, listContent in pairs(tabIdTable) do
    if listId == tabId then
      UI.setClass(listId, 'downloadTab activeTab')
      contentToShow = listContent
    else
      UI.setClass(listId, 'downloadTab')
    end
  end
  currentListItem = 1

  -- reset filters
  authorFilter, searchFilter = nil, nil
  UI.setAttribute("searchField", "text", "")
  UI.setAttribute("authorDropdown", "value", 0)

  updateDownloadItemList()
end

-- click function for the items in the download window
-- updates backgroundcolor for row panel and fontcolor for list item
function onClick_select(_, _, identificationKey)
  UI.setAttribute("panel" .. currentListItem, "color", "clear")
  UI.setAttribute(contentToShow .. "_" .. currentListItem, "color", "white")

  -- parses the identification key (contentToShow_currentListItem)
  if identificationKey then
    contentToShow = nil
    currentListItem = nil
    for str in string.gmatch(identificationKey, "([^_]+)") do
      if not contentToShow then
        -- grab the first part to know the content type
        contentToShow = str
      else
        -- get the index
        currentListItem = tonumber(str)
        break
      end
    end
  end

  UI.setAttribute("panel" .. currentListItem, "color", "grey")
  UI.setAttribute(contentToShow .. "_" .. currentListItem, "color", "black")
  updatePreviewWindow()
end

-- click function for the "Custom URL" button in the playarea image gallery
function onClick_customUrl(player)
  changeWindowVisibilityForColor(player.color, "playareaGallery")
  Wait.time(function()
    player.showInputDialog("Enter a custom URL for the playarea image", "", function(newURL)
      playAreaApi.updateSurface(newURL)
    end)
  end, 0.15)
end

-- click function for the download button in the preview window
function onClick_download(player)
  local params = library[contentToShow][currentListItem]
  params.player = player
  placeholder_download(params)
end

-- the download button on the placeholder objects calls this to directly initiate a download
---@param params table contains url and guid of replacement object
function placeholder_download(params)
  function downloadCoroutine()
    -- show progress bar
    UI.setAttribute('download_progress', 'active', true)

    -- update progress bar
    while requestObj do
      UI.setAttribute('download_progress', 'percentage', requestObj.download_progress * 100)
      coroutine.yield(0)
    end
    UI.setAttribute('download_progress', 'percentage', 100)

    -- wait 30 frames
    for i = 1, 30 do
      coroutine.yield(0)
    end

    -- hide progress bar
    UI.setAttribute('download_progress', 'active', false)

    -- hide download window
    if params.player then
      changeWindowVisibilityForColor(params.player.color, "downloadWindow", false)
    end
    return 1
  end

  local url = SOURCE_REPO .. params.filename .. ".json"
  requestObj = WebRequest.get(url, function(request) contentDownloadCallback(request, params) end)
  startLuaCoroutine(Global, 'downloadCoroutine')
end

-- spawns a bag that contains every object from the library
function onClick_downloadAll(player)
  broadcastToAll("Download initiated - this will take a few minutes!")

  -- hide download window
  changeWindowVisibilityForColor(player.color, "downloadWindow", false)

  startLuaCoroutine(Global, "coroutineDownloadAll")
end

function coroutineDownloadAll()
  local JSON = [[
    {
      "Name": "Bag",
      "Transform": {
        "posX": {{POSX}},
        "posY": 2,
        "posZ": -95,
        "rotX": 0,
        "rotY": 270,
        "rotZ": 0,
        "scaleX": 1,
        "scaleY": 1,
        "scaleZ": 1
      },
      "Nickname": "{{NICKNAME}}",
      "Bag": {
        "Order": 0
      },
      "ContainedObjects": [
  ]]

  local posx = -45.0
  local downloadedItems = 0
  local skippedItems = 0

  -- loop through the library to add content
  for contentType, objectList in pairs(library) do
    broadcastToAll("Downloading " .. contentType .. "...")
    local contained = ""
    for _, params in ipairs(objectList) do
      local request = WebRequest.get(SOURCE_REPO .. params.filename .. ".json", function() end)
      local start = os.time()
      while true do
        if request.is_done then
          contained = contained .. request.text .. ","
          downloadedItems = downloadedItems + 1
          break
          -- time-out if item can't be loaded in 5s
        elseif request.is_error or (os.time() - start) > 5 then
          skippedItems = skippedItems + 1
          break
        end
        coroutine.yield(0)
      end
    end
    local JSONCopy = JSON
    JSONCopy = JSONCopy .. contained .. "]}"
    JSONCopy = JSONCopy:gsub("{{POSX}}", posx)
    JSONCopy = JSONCopy:gsub("{{NICKNAME}}", contentType)
    spawnObjectJSON({ json = JSONCopy })
    posx = posx + 3
  end

  broadcastToAll(downloadedItems .. " objects downloaded.", "Green")
  broadcastToAll(skippedItems .. " objects had a time-out / error.", "Orange")
  return 1
end

-- spawns a placeholder box for the selected object
function onClick_spawnPlaceholder(player)
  -- get object references
  local item = library[contentToShow][currentListItem]
  local dummy = guidReferenceApi.getObjectByOwnerAndType("Mythos", "PlaceholderBoxDummy")

  -- error handling
  if not item.boxsize or item.boxsize == "" or not item.boxart or item.boxart == "" then
    print("Error loading object.")
    return
  end

  -- get data for placeholder
  local spawnPos = { -39.5, 2, -87 }

  local meshTable = {
    big = "https://steamusercontent-a.akamaihd.net/ugc/62583916778515295/AFB8F257CE1E4973F4C06160A2E156C147AEE1E3/",
    small = "https://steamusercontent-a.akamaihd.net/ugc/62583916778515333/9F0BE0C211BE3BD1725B4B855F5D3C9C0D020394/",
    wide = "https://steamusercontent-a.akamaihd.net/ugc/2278324073260846176/33EFCAF30567F8756F665BE5A2A6502E9C61C7F7/"
  }

  local scaleTable = {
    big = { 1.00, 0.14, 1.00 },
    small = { 2.21, 0.46, 2.42 },
    wide = { 2.00, 0.11, 1.69 }
  }

  local placeholder = spawnObject({
    type = "Custom_Model",
    position = spawnPos,
    rotation = { 0, 270, 0 },
    scale = scaleTable[item.boxsize],
  })

  placeholder.setCustomObject({
    mesh = meshTable[item.boxsize],
    diffuse = item.boxart,
    material = 3
  })

  if item.boxsize == "big" then
    placeholder.addTag("LargeBox")
  end

  placeholder.setColorTint({ 1, 1, 1, 71 / 255 })
  placeholder.setName(item.name)
  placeholder.setDescription("by " .. (item.author or "Unknown"))
  placeholder.setGMNotes(item.filename)
  placeholder.setLuaScript(dummy.getLuaScript())

  if player.color ~= "Grey" then
    player.pingTable(spawnPos)
  end

  -- hide download window
  changeWindowVisibilityForColor(player.color, "downloadWindow", false)
end

function onClick_toggleOptionPanel(player, clickType)
  if clickType == "-1" then
    -- regular behaviour for left-click
    local newState = changeWindowVisibilityForColor(player.color, "optionPanel")

    -- show/hide secondary windows
    if newState == true then
      changeWindowVisibilityForColor(player.color, "blessCurseManager", false)
      changeWindowVisibilityForColor(player.color, "actionTracker", false)
      changeWindowVisibilityForColor(player.color, "navPanelFull", false)
      changeWindowVisibilityForColor(player.color, "navPanelPlay", false)

      if not sentOptionPanelMessage[player.color] then
        printToColor("Right-click the Option Panel button to show presets.", player.color)
        sentOptionPanelMessage[player.color] = true
      end
    else
      if blurseVisibility[player.color] then
        changeWindowVisibilityForColor(player.color, "blessCurseManager", blurseVisibility[player.color])
      end
      if actionTrackerVisibility[player.color] then
        changeWindowVisibilityForColor(player.color, "actionTracker", actionTrackerVisibility[player.color])
      end
      navigationOverlayApi.updateVisibility()
    end
  elseif clickType == "-2" then
    -- right-click: show option presets
    local presetNames = {}
    for name, _ in pairs(OPTION_PRESETS) do
      table.insert(presetNames, name)
    end

    player.showOptionsDialog("Choose an option preset", presetNames, 1,
      function (presetName)
        loadOptionPanelState(OPTION_PRESETS[presetName])
        printToAll("Loaded option preset: " .. presetName, "Green")
      end)
  elseif clickType == "-3" then
    -- middle-click: directly load mods for your name
    local steamName = string.gsub(player.steam_name, "%s+", "") -- strip spaces from steam_name
    local options = OPTION_PRESETS[steamName]
    if options then
      loadOptionPanelState(options)
      printToAll("Loaded " .. player.steam_name .. "'s preferred options.", "Green")
    else
      printToAll("Didn't find " .. player.steam_name .. "'s preferred options.", "Yellow")
    end
  end
end

-- toggles the visibility of the respective UI
---@param player tts__Player Player that triggered this
---@param windowId string Name of the UI to toggle
function onClick_toggleUi(player, windowId)
  -- let the Navigation Overlay handle the toggling of its visibility modes
  if windowId == "Navigation Overlay" then
    navigationOverlayApi.cycleVisibility(player.color)
    changeWindowVisibilityForColor(player.color, "optionPanel", false)
    return
  end

  -- hide the playAreaGallery / downloadWindow if visible
  if windowId == "downloadWindow" then
    changeWindowVisibilityForColor(player.color, "playAreaGallery", false)
  elseif windowId == "playAreaGallery" then
    changeWindowVisibilityForColor(player.color, "downloadWindow", false)
  elseif windowId == "blessCurseManager" then
    -- store the state of the Bless/Curse Manager UI to restore it onLoad()
    blurseVisibility[player.color] = changeWindowVisibilityForColor(player.color, "blessCurseManager")

    changeWindowVisibilityForColor(player.color, "optionPanel", false)
    return
  elseif windowId == "actionTracker" then
    -- store the state of the Action Tracker UI to restore it onLoad()
    local visibility = changeWindowVisibilityForColor(player.color, "actionTracker")
    actionTrackerVisibility[player.color] = visibility
    printToColor("Action Tracker " .. (visibility and "enabled." or "disabled."), player.color)

    if visibility then
      if #playermatApi.getUsedMatColors() == 0 then
        printToColor("No player mats in use - place an investigator.", player.color)
      end
    end

    changeWindowVisibilityForColor(player.color, "optionPanel", false)
    return
  end

  changeWindowVisibilityForColor(player.color, windowId)
end

-- wrapper for the real function to unpack arguments
function changeWindowVisibilityForColorWrapper(params)
  changeWindowVisibilityForColor(params.color, params.windowId, params.overrideState, params.owner)
end

-- toggles the visibility of the specific window for the specified color
---@param color string Player color to toggle the visibility for
---@param windowId string ID of the XML element
---@param overrideState? boolean Forcefully sets the new visibility
---@param owner? tts__Object Object that owns the XML (or nil if Global)
---@return boolean visible Returns the new state of the visibility
function changeWindowVisibilityForColor(color, windowId, overrideState, owner)
  local targetUi = UI
  if owner then
    targetUi = owner.UI
  end

  -- current state
  local colorString = targetUi.getAttribute(windowId, "visibility") or ""

  -- parse the visibility string
  local visible = false
  local viewers = {}
  for str in string.gmatch(colorString, "%a+") do
    table.insert(viewers, str)
    if str == color then
      visible = true
    end
  end

  -- add / remove the color as viewer
  if visible == true then
    removeValueFromTable(viewers, color)
  elseif visible == false then
    table.insert(viewers, color)
  end
  visible = not visible

  -- resolve override
  if overrideState == true and visible == false then
    table.insert(viewers, color)
    visible = true
  elseif overrideState == false and visible == true then
    removeValueFromTable(viewers, color)
    visible = false
  end

  -- construct new string
  local newColorString = ""
  for _, viewer in ipairs(viewers) do
    newColorString = newColorString .. viewer .. "|"
  end

  -- remove last delimiter
  newColorString = newColorString:sub(1, -2)

  -- update the visibility of the XML
  targetUi.setAttribute(windowId, "visibility", newColorString)
  targetUi.setAttribute(windowId, "active", newColorString ~= "")

  return visible
end

-- updates the preview window
function updatePreviewWindow()
  local item = library[contentToShow][currentListItem]
  local tempImage =
  "https://steamusercontent-a.akamaihd.net/ugc/2115061845788345842/2CD6ABC551555CCF58F9D0DDB7620197BA398B06/"

  -- set default image if not defined
  if item.boxsize == nil or item.boxsize == "" or item.boxart == nil or item.boxart == "" then
    item.boxsize = "big"
    item.boxart =
    "https://steamusercontent-a.akamaihd.net/ugc/762723517667628371/18438B0A0045038A7099648AA3346DFCAA267C66/"
  end

  UI.setValue("previewTitle", item.name)
  UI.setValue("previewAuthor", "by " .. (item.author or "- Author not found -"))
  UI.setValue("previewDescription", item.description or "- Description not found -")

  -- update mask according to size (hardcoded values to align image in mask)
  local maskData = {}
  if item.boxsize == "big" then
    maskData = {
      image = "box-cover-mask-big",
      width = "870",
      height = "435",
      offsetXY = "154 60"
    }
  elseif item.boxsize == "small" then
    maskData = {
      image = "box-cover-mask-small",
      width = "792",
      height = "594",
      offsetXY = "135 13"
    }
  elseif item.boxsize == "wide" then
    maskData = {
      image = "box-cover-mask-wide",
      width = "756",
      height = "630",
      offsetXY = "-190 -70"
    }
  end

  -- loading empty image as placeholder until real image is loaded
  UI.setAttribute("previewArtImage", "image", tempImage)

  -- insert the image itself
  UI.setAttribute("previewArtImage", "image", item.boxart)
  UI.setAttributes("previewArtMask", maskData)
end

-- formats the json response from the webrequest into a key-value lua table
function formatLibrary(jsonResponse)
  library = {}

  for _, item in ipairs(jsonResponse["content"]) do
    local contentType = item["type"]

    -- add "fanmade" for unofficial content
    if item["author"] ~= "Fantasy Flight Games" then
      contentType = "fanmade-" .. contentType
    end

    -- initialize subtable
    if library[contentType] == nil then
      library[contentType] = {}
    end
    table.insert(library[contentType], item)
  end
end

-- updates the window content to the requested content
---@param skipAuthorUpdate? boolean If true, skips the update for the author dropdown
function updateDownloadItemList(skipAuthorUpdate)
  if not library then return end

  -- addition of list items according to library file
  local globalXml = UI.getXmlTable()
  local contentList = getXmlTableElementById(globalXml, 'contentList')

  -- reset the list of authors unless skipping
  if not skipAuthorUpdate then
    authorList = {}
  end

  contentList.children = {}
  for i, v in ipairs(library[contentToShow]) do
    -- if there's a filter, apply it (both for name and author)
    if (searchFilter == nil or string.contains(string.lower(v.name), searchFilter)) and
        (authorFilter == nil or v.author == authorFilter) then
      -- start collecting authors unless skipping
      if not skipAuthorUpdate then
        table.insert(authorList, v.author)
      end

      table.insert(contentList.children,
        {
          tag = "Panel",
          attributes = { id = "panel" .. i },
          children = {
            tag = 'Text',
            value = v.name,
            attributes = {
              id = contentToShow .. "_" .. i,
              onClick = 'onClick_select',
              alignment = 'MiddleLeft'
            }
          }
        })
    end
  end

  contentList.attributes.height = #contentList.children * 27

  -- populate the author dropdown with options unless skipping
  if not skipAuthorUpdate then
    authorList = removeDuplicatesAndSort(authorList)

    local authorDropdown = getXmlTableElementById(globalXml, 'authorDropdown')
    authorDropdown.children = { { tag = "Option", value = "All authors" } }
    for _, author in ipairs(authorList) do
      table.insert(authorDropdown.children, { tag = "Option", value = author })
    end
  end

  updateGlobalXml(globalXml)

  -- select the first item
  Wait.time(onClick_select, 0.2)
end

function createActionTrackerUI()
  -- make list of currently used mat colors
  local usedMatColors = playermatApi.getUsedMatColors()
  local isUsed = {}
  for _, matColor in ipairs(usedMatColors) do
    isUsed[matColor] = true
  end

  local visibilityString = ""
  for playerColor, state in pairs(actionTrackerVisibility) do
    if state then
      visibilityString = visibilityString .. playerColor .. "|"
    end
  end

  -- remove last delimiter
  if visibilityString ~= "" then
    visibilityString = visibilityString:sub(1, -2)
  end

  local actionTrackerXml = {
    tag = "TableLayout",
    attributes = {
      id                                   = "actionTracker",
      color                                = "black",
      visibility                           = visibilityString,
      active                               = visibilityString ~= "",
      height                               = 30 * #usedMatColors,
      width                                = "300",
      offsetXY                             = "-2 396",
      columnWidths                         = "0 25 25 25 25 25",
      padding                              = "4 4 4 4",
      cellSpacing                          = "5",
      allowDragging                        = true,
      returnToOriginalPositionWhenReleased = false,
      rectAlignment                        = "LowerRight",
      raycastTarget                        = true,
      outlineSize                          = "2 2",
      outline                              = "#303030"
    },
    children = {}
  }

  -- Loop through playermats and create rows in the Action Tracker
  for matColor, _ in pairs(guidReferenceApi.getObjectsByType("Playermat")) do
    local playerColor = playermatApi.getPlayerColor(matColor)
    local playerRow = {
      tag = "Row",
      attributes = { id = "playerRow" .. matColor, active = isUsed[matColor] or false },
      children = {
        {
          tag = "Cell",
          children = {
            {
              tag = "Text",
              attributes = {
                id    = "playerName" .. matColor,
                color = playerColor,
                text  = getDisplayName(matColor)
              }
            }
          }
        }
      }
    }

    local actionCount = determineActionCount(matColor)

    for j = 1, 5 do
      local color = "black"
      if j <= actionCount.total then
        if actionCount.order[j] == true then
          color = "#C89B3C" -- gold for accessibility
        else
          color = "grey"
        end
      end

      local actionXml = {
        tag = "Cell",
        children = {
          tag = "Panel",
          attributes = { id = "playerAction" .. j .. matColor, color = color }
        }
      }
      table.insert(playerRow.children, actionXml)
    end
    table.insert(actionTrackerXml.children, playerRow)
  end

  local xml = UI.getXmlTable()
  table.insert(xml, actionTrackerXml)
  updateGlobalXml(xml)
end

-- updates the layout of the action tracker
function updateActionTrackerRows()
  local usedMatColors = playermatApi.getUsedMatColors()
  local isUsed = {}
  for _, matColor in ipairs(usedMatColors) do
    isUsed[matColor] = true
  end

  UI.setAttribute("actionTracker", "height", 30 * #usedMatColors)
  for matColor, _ in pairs(guidReferenceApi.getObjectsByType("Playermat")) do
    UI.setAttribute("playerRow" .. matColor, "active", isUsed[matColor] or false)
  end
end

-- updates the color of the actions based on the playermats actions tokens
function updateActionTrackerTokens(matColor, delayFrames)
  if waitIds["actionTrackerTokens" .. matColor] then
    Wait.stop(waitIds["actionTrackerTokens" .. matColor])
    waitIds["actionTrackerTokens" .. matColor] = nil
  end
  waitIds["actionTrackerTokens" .. matColor] = Wait.frames(function()
    local actionCount = determineActionCount(matColor)
    for i = 1, 5 do
      local color = "black"
      if i <= actionCount.total then
        if actionCount.order[i] == true then
          color = "#C89B3C" -- gold for accessibility
        else
          color = "grey"
        end
      end
      UI.setAttribute("playerAction" .. i .. matColor, "color", color)
    end
    waitIds["actionTrackerTokens" .. matColor] = nil
  end, delayFrames or 50)
end

-- updates the displayed names in the action tracker
function updateActionTrackerName(matColor)
  local textColor = "grey"
  local fontStyle = "Italic"

  if isMiniReady(matColor) then
    textColor = playermatApi.getPlayerColor(matColor)
    fontStyle = "Normal"
  end

  UI.setAttributes("playerName" .. matColor, {
    color     = textColor,
    fontStyle = fontStyle,
    text      = getDisplayName(matColor)
  })
  updateActionTrackerRows()
end

function isMiniReady(matColor)
  local investigatorData = playermatApi.getActiveInvestigatorData(matColor)
  if not investigatorData then return false end

  local playAreaZone = guidReferenceApi.getObjectByOwnerAndType("Mythos", "PlayAreaZone")
  for _, obj in ipairs(playAreaZone.getObjects()) do
    if obj.hasTag("Minicard") and not obj.is_face_down then
      local md = JSON.decode(obj.getGMNotes()) or {}
      if md.id == investigatorData.miniId then return true end
    end
  end
  return false
end

function determineActionCount(matColor)
  local playermat = guidReferenceApi.getObjectByOwnerAndType(matColor, "Playermat")
  if not playermat then return end

  local localPos     = Vector(-1.2, 0.1, -0.28)
  local pos          = playermatApi.transformLocalPosition(localPos, matColor):setAt("y", 3)
  local rot          = playermatApi.returnRotation(matColor)
  local size         = Vector(5, 6, 0.1)
  local searchResult = searchLib.inArea(pos, rot, size, "isUniversalToken")

  local actionCount  = {
    available = 0,
    used      = 0,
    total     = #searchResult,
    order     = {}
  }

  -- sort tokens from left to right
  local tokenPositions = {}
  for _, obj in ipairs(searchResult) do
    tokenPositions[obj] = playermat.positionToLocal(obj.getPosition())
  end

  table.sort(searchResult, function(a, b) return tokenPositions[a].x > tokenPositions[b].x end)

  for _, obj in ipairs(searchResult) do
    if obj.is_face_down then
      actionCount.used = actionCount.used + 1
    else
      actionCount.available = actionCount.available + 1
    end
    table.insert(actionCount.order, not obj.is_face_down)
  end

  return actionCount
end

-- returns the display name (steam name or investigator)
function getDisplayName(matColor)
  local playerColor = playermatApi.getPlayerColor(matColor)

  -- if the mat was removed or something wierd happened, just return the matColor
  if not playerColor then return matColor end

  -- return steam name if there's a seated player
  if Player[playerColor] and Player[playerColor].steam_name then
    return Player[playerColor].steam_name
  end

  -- return investigator name if possible
  local investigatorName = playermatApi.getInvestigatorName(matColor)
  if investigatorName ~= "" then
    return investigatorName
  end

  -- default to playerColor
  return playerColor
end

-- this helper function updates the global XML while preserving the visibility of windows
function updateGlobalXml(newXml)
  -- preserve visibility settings for these elements
  local windowIdList = {
    "playAreaGallery",
    "downloadWindow",
    "optionPanel",
    "blessCurseManager"
  }

  -- get current state and update newXml
  for _, windowId in ipairs(windowIdList) do
    local element = getXmlTableElementById(newXml, windowId)
    if element and element.attributes then
      element.attributes.active = UI.getAttribute(windowId, "active")
      element.attributes.visibility = UI.getAttribute(windowId, "visibility")
    end
  end

  UI.setXmlTable(newXml)
end

-- called after the webrequest of downloading an item
-- deletes the placeholder and spawns the downloaded item
function contentDownloadCallback(request, params)
  requestObj = nil

  -- error handling
  if request.is_error or request.response_code ~= 200 then
    print('Error: ' .. request.error)
    return
  end

  -- initiate content spawning
  local spawnTable = { json = request.text }
  if params.replace then
    local replacedObject = getObjectFromGUID(params.replace)
    if replacedObject then
      spawnTable.position = replacedObject.getPosition()
      spawnTable.rotation = replacedObject.getRotation()
      spawnTable.scale    = replacedObject.getScale()
      destroyObject(replacedObject)
    end
  end

  -- if position is undefined, get empty position
  if not spawnTable.position then
    local pos = getValidSpawnPosition()
    if not pos then
      broadcastToAll("Please make sure there's space in the upper middle of the table and try again.", "Red")
      return
    end

    spawnTable.position = pos
    spawnTable.rotation = { 0, 270, 0 }
  end

  spawnTable["callback_function"] = function(obj)
    Wait.time(function()
      -- if spawned from menu, move the camera and/or ping the table
      if params.name then
        -- move camera
        if params.player then
          params.player.lookAt({
            position = obj.getPosition(),
            pitch    = 65,
            yaw      = 90,
            distance = 65
          })
        end

        -- ping object
        local pingPlayer = params.player or Player.getPlayers()[1]
        if pingPlayer.color ~= "Grey" then
          pingPlayer.pingTable(obj.getPosition())
        end
      end

      -- add gmnotes for "reloading"
      obj.setGMNotes(params.filename)
      obj.addTag("Reloadable")
      onObjectSpawn(obj)
    end, 0.1)
  end

  if pcall(function() spawnObjectJSON(spawnTable) end) then
    print('Object loaded.')
  else
    print('Error loading object.')
  end
end

-- gets the first empty position to spawn a custom content object safely
function getValidSpawnPosition()
  local potentialSpawnPositionX = { 65, 50, 35 }
  local potentialSpawnPositionY = 1.5
  local potentialSpawnPositionZ = { 35, 21, 7, -7, -21, -35 }

  for _, posX in ipairs(potentialSpawnPositionX) do
    for _, posZ in ipairs(potentialSpawnPositionZ) do
      local pos = Vector(posX, potentialSpawnPositionY, posZ)
      if checkPositionForContentSpawn(pos) then
        return pos
      end
    end
  end
  return nil
end

-- checks whether something is in the specified position
-- first hit is the table surface, additional hits means something is there
---@return boolean: True if empty
function checkPositionForContentSpawn(checkPos)
  local searchResult = searchLib.atPosition(checkPos, "isInteractable")
  return #searchResult == 0
end

-- downloading of the library file
function libraryDownloadCallback(request)
  if request.is_error or request.response_code ~= 200 then
    print('error: ' .. request.error)
    return
  end

  local jsonResponse = nil
  if pcall(function() jsonResponse = JSON.decode(request.text) end) then
    formatLibrary(jsonResponse)
    updateDownloadItemList()
  else
    print('error parsing downloaded library')
  end
end

-- loops through an XML table and returns the specified object
---@param ui table XmlTable (get this via getXmlTable)
---@param id string Id of the object to return
function getXmlTableElementById(ui, id)
  for _, obj in ipairs(ui) do
    if obj.attributes and obj.attributes.id and obj.attributes.id == id then return obj end
    if obj.children then
      local result = getXmlTableElementById(obj.children, id)
      if result then return result end
    end
  end
  return nil
end

---------------------------------------------------------
-- Option Panel related functionality
---------------------------------------------------------

-- changes the UI state and the internal variable for the togglebuttons
function onClick_toggleOption(_, _, id)
  local currentState = optionPanel[id]
  local newState = not currentState
  applyOptionPanelChange(id, newState)
  UI.setAttribute(id, "image", newState and "option_on" or "option_off")
end

-- color selection for playArea
function onClick_playAreaConnectionColor(player, _, id)
  player.showColorDialog(optionPanel[id], function(color)
    applyOptionPanelChange(id, color)
  end)
end

-- called by the language selection dropdown
function languageSelected(_, selectedIndex, id)
  optionPanel[id] = LANGUAGES[tonumber(selectedIndex) + 1].code
end

-- returns the ID (position in the table) for a provided language code
function returnLanguageId(code)
  for index, tbl in ipairs(LANGUAGES) do
    if tbl.code == code then
      return index
    end
  end
end

-- called by the resource counter selection dropdown
function resourceCounterSelected(_, selectedIndex, id)
  optionPanel[id] = RESOURCE_OPTIONS[tonumber(selectedIndex) + 1]
end

-- returns the ID for the provided option name
function returnResourceCounterId(name)
  for index, optionName in ipairs(RESOURCE_OPTIONS) do
    if optionName == name then
      return index
    end
  end
end

-- called by the playermat removal selection dropdown
function playermatRemovalSelected(player, selectedIndex, id)
  if selectedIndex == "0" then return end

  local matColorList = { "White", "Orange", "Green", "Red" }
  local matColor = matColorList[tonumber(selectedIndex)]
  local mat = guidReferenceApi.getObjectByOwnerAndType(matColor, "Playermat")

  if mat then
    -- confirmation dialog about deletion
    if player.color ~= "Grey" then
      player.pingTable(mat.getPosition())
    end
    player.showConfirmDialog("Do you really want to remove " .. matColor .. "'s playermat and related objects?",
      function() removePlayermat(matColor) end)
  else
    player.showConfirmDialog("Do you want to respawn " .. matColor .. "'s playermat and related objects?",
    function() spawnPlayermat(matColor) end)
  end

  -- set selected value back to first option
  UI.setAttribute(id, "value", 0)
end

-- removes a playermat and all related objects from play
---@param matColor string Color of the playermat to remove
function removePlayermat(matColor)
  -- if there's a seated player, move them to grey
  local handColor = playermatApi.getPlayerColor(matColor)
  if Player[handColor].seated then
    Player[handColor].changeColor("Grey")
  end

  local matObjects = guidReferenceApi.getObjectsByOwner(matColor)
  if not matObjects.Playermat then return end

  -- remove action tokens
  local actionTokens = playermatApi.searchAroundPlayermat(matColor, "isUniversalToken")
  for _, obj in ipairs(actionTokens) do
    obj.destruct()
  end

  -- remove mat owned objects
  for _, obj in pairs(matObjects) do
    obj.destruct()
  end

  -- update index
  guidReferenceApi.editIndex(matColor)

  -- update the action tracker
  updateActionTrackerRows()
end

function spawnPlayermat(matColor)
  local sourceBag = guidReferenceApi.getObjectByOwnerAndType("Mythos", "ObjectSourceBag")

  -- error handling for missing sourceBag
  if not sourceBag then
    broadcastToAll("Option panel source bag could not be found!", "Red")
    return
  end

  local defaultPosition = {
    White  = Vector( -55, 1.45, 16.1 ),
    Orange = Vector( -55, 1.45, -16.1 ),
    Green  = Vector( -30.35, 1.45, 26.6 ),
    Red    = Vector( -30.35, 1.45, -26.6 )
  }
  local defaultRotation = {
    White  = Vector( 0, 270, 0 ),
    Orange = Vector( 0, 270, 0 ),
    Green  = Vector( 0, 0, 0 ),
    Red    = Vector( 0, 180, 0 )
  }
  local indexNames = {
    ["Clues"]     = "ClickableClueCounter",
    ["Damage"]    = "DamageCounter",
    ["Horror"]    = "HorrorCounter",
    ["Resources"] = "ResourceCounter"
  }
  function spawnCoro()
    -- collect spawndata
    local spawnData = {}
    for _, objData in ipairs(sourceBag.getData().ContainedObjects) do
      if objData.Nickname == "Playermat Objects" then
        for _, deepObjData in ipairs(objData.ContainedObjects) do
          local name = deepObjData.Nickname
          if name == nil or name == "" then name = "HandZone" end
          spawnData[name] = deepObjData
        end
      end
    end

    -- handle mat spawning first
    updateTransformData(spawnData.Playermat, defaultPosition[matColor], defaultRotation[matColor])

    -- update color data of mat
    spawnData.Playermat.Memo = matColor
    local scriptState = JSON.decode(spawnData.Playermat.LuaScriptState)
    scriptState.playerColor = matColor
    spawnData.Playermat.LuaScriptState = JSON.encode(scriptState)

    -- spawn the mat
    local playermat = spawnObjectData({ data = spawnData.Playermat })
    coWaitFrames(10)
    guidReferenceApi.editIndex(matColor, "Playermat", playermat.getGUID())

    -- spawn objects
    for name, objData in pairs(spawnData) do
      if name ~= "Playermat" then
        local localPos = zones.getLocalZoneData(matColor, name)
        if localPos then
          local pos = playermat.positionToWorld(localPos)
          local rot = defaultRotation[matColor]:copy()

          if name == "Hand" then
            rot = rot + Vector(0, 180, 0)
          elseif name == "Damage" or name == "Horror" then
            rot = rot + Vector(0, 10, 180)
          elseif name == "Clues" or name == "Clue Counter" or name == "Resources" then
            rot = rot + Vector(0, 10, 0)
          end

          updateTransformData(objData, pos, rot)
          local obj = spawnObjectData({ data = objData })
          coWaitFrames(3)

          -- update index
          local indexName = string.gsub(name, " ", "")
          guidReferenceApi.editIndex(matColor, indexName or indexNames[indexName], obj.getGUID())
        end
      end
    end

    -- also spawn any helpers that are already enabled (hardcoded list atm)
    for _, helperName in ipairs({ "Hand Helper", "Search Assistant "}) do
      if optionPanel["show" .. string.gsub(helperName, " ", "")] then
        local data = playermatApi.getHelperSpawnData(matColor, helperName)
        spawnOrRemoveHelper(state, helperName, data.position, data.rotation, matColor)
        coWaitFrames(3)
      end
    end

    -- ensure playermat has correct references
    playermat.call("getOwnedObjects")

    -- update the action tracker
    updateActionTrackerRows()
    return 1
  end
  startLuaCoroutine(Global, "spawnCoro")
end

function updateTransformData(data, position, rotation)
  data.Transform.posX = position.x
  data.Transform.posY = position.y
  data.Transform.posZ = position.z
  data.Transform.rotX = rotation.x
  data.Transform.rotY = rotation.y
  data.Transform.rotZ = rotation.z
end

-- sets the option panel to the correct state (corresponding to 'optionPanel')
function updateOptionPanelState()
  for id, optionValue in pairs(optionPanel) do
    if id == "cardLanguage" and type(optionValue) == "string" then
      local dropdownId = returnLanguageId(optionValue) - 1
      UI.setAttribute(id, "value", dropdownId)
    elseif id == "useResourceCounters" and type(optionValue) == "string" then
      local dropdownId = returnResourceCounterId(optionValue) - 1
      UI.setAttribute(id, "value", dropdownId)
    elseif id == "playAreaConnectionColor" then
      UI.setAttribute(id, "color", "#" .. Color.new(optionValue):toHex())
    elseif (type(optionValue) == "boolean" and optionValue)
        or (type(optionValue) == "string" and optionValue)
        or (type(optionValue) == "table" and #optionValue ~= 0) then
      UI.setAttribute(id, "image", "option_on")
    else
      UI.setAttribute(id, "image", "option_off")
    end
  end
end

-- handles the applying of option selections and calls the respective functions based on the id
---@param id string ID of the option that was selected or deselected
---@param state boolean|any State of the option (true = enabled)
function applyOptionPanelChange(id, state)
  optionPanel[id] = state

  -- option: Snap tags
  if id == "useSnapTags" then
    playermatApi.setLimitSnapsByType(state, "All")

    -- option: Draw 1 button
  elseif id == "showDrawButton" then
    playermatApi.showDrawButton(state, "All")

    -- option: Use class texture
  elseif id == "useClassTexture" then
    playermatApi.useClassTexture(state, "All")

    -- option: Clickable clue counters
  elseif id == "useClueClickers" then
    playermatApi.clickableClues(state, "All")

    -- update master clue counter
    local counter = guidReferenceApi.getObjectByOwnerAndType("Mythos", "MasterClueCounter")
    counter.call("setClickableCounters", state)

    -- option: Enable card helpers
  elseif id == "enableCardHelpers" then
    toggleCardHelpers(state)

    -- option: Make damage / horror clickable // Show '1' on damage / horror
  elseif id == "makeDamageHorrorClickable" or id == "showOneDamageHorror" then
    for _, obj in ipairs(getObjects()) do
      local memo = obj.getMemo()
      if memo == "damage" or memo == "horror" then
        local func = obj.getVar("updateLabel")
        if func then obj.call("updateLabel") end
      end
    end

    -- option: Play area connection drawing
  elseif id == "playAreaConnections" then
    playAreaApi.setConnectionDrawState(state)

    -- option: Play area connection color
  elseif id == "playAreaConnectionColor" then
    playAreaApi.setConnectionColor(state)
    UI.setAttribute(id, "color", "#" .. Color.new(state):toHex())

    -- option: Play area snap tags
  elseif id == "playAreaSnapTags" then
    playAreaApi.setLimitSnapsByType(state)

    -- option: Show clean up helper
  elseif id == "showCleanUpHelper" then
    spawnOrRemoveHelper(state, "Clean Up Helper", { -66, 1.53, 46 })

    -- option: Show hand helper for each player
  elseif id == "showHandHelper" then
    spawnOrRemoveHelperForPlayermats("Hand Helper", state)

    -- option: Show search assistant for each player
  elseif id == "showSearchAssistant" then
    spawnOrRemoveHelperForPlayermats("Search Assistant", state)

    -- option: Show attachment helper
  elseif id == "showAttachmentHelper" then
    spawnOrRemoveHelper(state, "Attachment Helper", { -62, 1.4, 0 })

    -- option: Show CYOA campaign guides
  elseif id == "showCYOA" then
    spawnOrRemoveHelper(state, "CYOA Campaign Guides", { 39, 1.3, -20 })

    -- option: Show displacement tool
  elseif id == "showDisplacementTool" then
    spawnOrRemoveHelper(state, "Displacement Tool", { -57, 1.53, 46 })
  end
end

-- spawns or removes a helper object for all playermats
---@param helperName string Name of the helper object
---@param state boolean Contains the state of the option: true = spawn it, false = remove it
function spawnOrRemoveHelperForPlayermats(helperName, state)
  for color, data in pairs(playermatApi.getHelperSpawnData("All", helperName)) do
    spawnOrRemoveHelper(state, helperName, data.position, data.rotation, color)
  end

  -- also spawn/remove the search assistant for the encounter deck
  if helperName == "Search Assistant" then
    local mythosArea = guidReferenceApi.getObjectByOwnerAndType("Mythos", "MythosArea")
    local pos = mythosArea.positionToWorld(Vector(0.880, 0.1, 0.868))
    local rot = mythosArea.getRotation()
    spawnOrRemoveHelper(state, "Encounter Search Assistant", pos, rot, "Mythos")
  end
end

-- handler for spawn / remove functions of helper objects
---@param state boolean Contains the state of the option: true = spawn it, false = remove it
---@param name string Name of the helper object
---@param position tts__Vector Position of the object (where it will spawn)
---@param rotation? tts__Vector Rotation of the object for spawning (default: {0, 270, 0})
---@param owner? string Owner of the object (defaults to "Mythos")
---@return string|nil GUID GUID of the spawnedObj (or nil if object was removed)
function spawnOrRemoveHelper(state, name, position, rotation, owner)
  if state then
    local pingPlayer = Player.getPlayers()[1]
    if pingPlayer.color ~= "Grey" then
      pingPlayer.pingTable(position)
    end
    local spawnedGUID = spawnHelperObject(name, position, rotation).getGUID()
    local cleanName = name:gsub("%s+", "")
    guidReferenceApi.editIndex(owner or "Mythos", cleanName, spawnedGUID)
  else
    removeHelperObject(name)
  end
end

-- copies the specified tool (by name) from the option panel source bag
---@param name string Name of the object that should be copied
---@param position tts__Vector Desired position of the object
---@param rotation? tts__Vector Desired rotation of the object (defaults to object's rotation)
function spawnHelperObject(name, position, rotation)
  local sourceBag = guidReferenceApi.getObjectByOwnerAndType("Mythos", "ObjectSourceBag")

  -- error handling for missing sourceBag
  if not sourceBag then
    broadcastToAll("Option panel source bag could not be found!", "Red")
    return
  end

  local spawnTable = { position = position }

  -- only overrride rotation if there is one provided (object's rotation used instead)
  if rotation then
    spawnTable.rotation = rotation
  end

  for _, objData in ipairs(sourceBag.getData().ContainedObjects) do
    if objData["Nickname"] == name then
      objData["Locked"] = true
      spawnTable.data = objData
      return spawnObjectData(spawnTable)
    end
  end
end

-- removes the specified tool (by name)
---@param name string Object that should be removed
function removeHelperObject(name)
  local cleanName = name:gsub("%s+", "")
  for _, obj in pairs(guidReferenceApi.getObjectsByType(cleanName)) do
    obj.destruct()
  end
end

-- loads saved options
---@param newOptions table Contains the new state for the option panel
function loadOptionPanelState(newOptions)
  for id, state in pairs(newOptions) do
    if optionPanel[id] ~= state then
      optionPanel[id] = state
      applyOptionPanelChange(id, state)
    end
  end

  -- update XML UI state
  updateOptionPanelState()
end

-- loads the default options
function onClick_defaultSettings()
  -- clean reset of variables
  optionPanel = {
    cardLanguage              = "en",
    changePlayAreaImage       = false,
    enableCardHelpers         = true,
    makeDamageHorrorClickable = true,
    playAreaConnectionColor   = { a = 1, b = 0.4, g = 0.4, r = 0.4 },
    playAreaConnections       = true,
    playAreaSnapTags          = true,
    showAttachmentHelper      = false,
    showCleanUpHelper         = false,
    showCYOA                  = false,
    showDisplacementTool      = false,
    showDrawButton            = false,
    showHandHelper            = false,
    showOneDamageHorror       = false,
    showSearchAssistant       = false,
    showTitleSplash           = true,
    useClassTexture           = true,
    useClueClickers           = false,
    useResourceCounters       = "disabled",
    useSnapTags               = true
  }

  -- applying changes
  for id, state in pairs(optionPanel) do
    applyOptionPanelChange(id, state)
  end

  -- update UI
  updateOptionPanelState()
end

-- splash scenario title on setup
function titleSplash(scenarioName)
  if optionPanel['showTitleSplash'] then
    -- if there's any ongoing title being displayed, hide it and cancel the waiting function
    if waitIds["hideTitleSplash"] then
      Wait.stop(waitIds["hideTitleSplash"])
      waitIds["hideTitleSplash"] = nil
      UI.setAttribute('title_splash', 'active', false)
    end

    -- display scenario name and set a 4 seconds (2 seconds animation and 2 seconds on screen)
    -- wait timer to hide the scenario name
    UI.setValue('title_splash_text', scenarioName)
    UI.show('title_splash')
    waitIds["hideTitleSplash"] = Wait.time(function()
      UI.hide('title_splash')
      waitIds["hideTitleSplash"] = nil
    end, 4)

    soundCubeApi.playSoundByName("Deep Bell")
  end
end

-- turns off all card helpers, if they are on
function toggleCardHelpers(state)
  for _, obj in ipairs(getObjectsWithTag("CardWithHelper")) do
    local owner = guidReferenceApi.getOwnerOfObject(obj)
    if owner == "Mythos" then return end

    local mat      = guidReferenceApi.getObjectByOwnerAndType(owner, "Playermat")
    local relPos   = mat.positionToLocal(obj.getPosition())
    local metadata = JSON.decode(obj.getGMNotes()) or {}
    local cardType = metadata.type

    if relPos.x > -1.5 and relPos.z > -0.3 and
        (cardType == "Asset" or cardType == "Investigator" or cardType == "Event") then
      obj.call("setHelperState", state)
    elseif relPos.x > -1.5 and relPos.z < -0.3 and cardType == "Skill" then
      obj.call("setHelperState", state)
    end
  end
end

-- toggles the hand visibility of a hand for a specific player
function handVisibilityToggle(params)
  local playerColor = params.playerColor
  local handColor = params.handColor

  -- collect data for message
  local state, preposition

  -- modify data table
  if not handVisibility[handColor] then
    handVisibility[handColor] = { playerColor, handColor }
    state, preposition = "Showing", "to"
  elseif removeValueFromTable(handVisibility[handColor], playerColor) then
    -- something was removed, maybe clear the table
    if #handVisibility[handColor] == 1 and handVisibility[handColor][1] == handColor then
      handVisibility[handColor] = nil
    end
    state, preposition = "Hiding", "from"
  else
    -- add the new color as viewer
    table.insert(handVisibility[handColor], playerColor)
    state, preposition = "Showing", "to"
  end

  local sourceName = getColoredName(handColor)
  local targetName = getColoredName(playerColor)
  broadcastToAll(state .. " " .. sourceName .. "'s hand " .. preposition .. " " .. targetName .. ".")
  updateHandVisibility()
end

function updateHandVisibility()
  -- update the global setting
  if not next(handVisibility) then
    Hands.hiding = 1
  else
    Hands.hiding = 3
  end

  -- update visibility of cards already in hands (delay seems to be necessary)
  Wait.frames(function()
    for _, handColor in ipairs(Player.getAvailableColors()) do
      for _, handObj in ipairs(Player[handColor].getHandObjects()) do
        applyHidingToCard(handObj, handColor)
      end
    end
  end, 1)
end

-- maybe hide card from non-allowed players
---@param card tts__Object Card to maybe hide
---@param handColor? string Color of the hand this card is in
function applyHidingToCard(card, handColor)
  if next(handVisibility) then
    local viewers = { handColor }
    if handColor and handVisibility[handColor] then
      viewers = handVisibility[handColor]
    end

    local hiddenFrom = Player.getColors()
    for _, viewer in ipairs(viewers) do
      removeValueFromTable(hiddenFrom, viewer)
    end
    card.setHiddenFrom(hiddenFrom)
  else
    card.setHiddenFrom({})
  end
end

-- loads the visibility of the Bless/Curse Manager XML from the internal variable
function updateBlurseVisibility()
  local count = 1
  for playerColor, state in pairs(blurseVisibility) do
    Wait.frames(function() changeWindowVisibilityForColor(playerColor, "blessCurseManager", state) end, count)
    count = count + 3
  end
end

---------------------------------------------------------
-- Update notification related functionality
---------------------------------------------------------

-- grabs the latest mod version and release notes from GitHub (called onLoad())
function getModVersion()
  WebRequest.get(SOURCE_REPO .. 'modversion.json', compareVersion)
end

-- compares the modversion with GitHub and possibly shows the update notification
function compareVersion(request)
  if request.is_error then
    log(request.error)
    return
  end

  -- global variable to make it accessible for other functions
  modMeta = JSON.decode(request.text)

  -- maybe update SOURCE_REPO to specific version
  if modMeta["setSpecificDownloadVersion"] then
    local versionTable = modMeta["setSpecificDownloadVersion"][1]
    if versionTable[MOD_VERSION] then
      SOURCE_REPO = "https://github.com/Chr1Z93/SCED-downloads/releases/download/" .. versionTable[MOD_VERSION] .. "/"
      log("Using download repo version: " .. versionTable[MOD_VERSION])
    end
  end

  -- stop here if on latest or newer version
  if convertVersionToNumber(MOD_VERSION) >= convertVersionToNumber(modMeta["latestVersion"]) then return end

  -- stop here if "don't show again" was clicked for this version before
  if acknowledgedUpgradeVersions[modMeta["latestVersion"]] then return end

  updateNotificationLoading()

  -- delay to avoid lagging during onLoad()
  Wait.time(function() UI.show("FinnIcon") end, 1)
end

-- converts a version number to a string
---@param version string Version number, separated by dots (e.g. 3.3.1)
function convertVersionToNumber(version)
  local major, minor, patch = string.match(version, "(%d+)%.(%d+)%.(%d+)")
  return major * 100 + minor * 10 + patch
end

-- updates the XML update notification based on the mod metadata
function updateNotificationLoading()
  -- grab data
  local highlights = modMeta["releaseHighlights"]

  -- concatenate the release highlights
  local highlightText = "• " .. highlights[1]
  for i, entry in pairs(highlights) do
    if i ~= 1 then
      highlightText = highlightText .. "\n• " .. entry
    end
  end

  -- update the XML UI
  UI.setValue("notificationHeader", "New version available: " .. modMeta["latestVersion"])
  UI.setValue("releaseHighlightText", highlightText)
  UI.setAttribute("highlightRow", "preferredHeight", 20 * #highlights)
  UI.setAttribute("updateNotification", "height", 20 * #highlights + 125)
end

-- close / don't show again buttons on the update notification
function onClick_notification(_, parameter)
  if parameter == "dontShowAgain" then
    -- this variable tracks if "don't show again" was pressed for a version
    acknowledgedUpgradeVersions[modMeta["latestVersion"]] = true
  end
  UI.hide("FinnIcon")
  UI.hide("updateNotification")
end

---------------------------------------------------------
-- Token Manager
---------------------------------------------------------

function TokenManager.initialize()
  TokenManager.generateOffsets(12)
  TokenManager.initTokenTemplates()
end

-- Generates the offsets for tokens on a card (clues on locations are different and have their own function)
---@param maxTokens number Maximum amount of tokens on a card
function TokenManager.generateOffsets(maxTokens)
  tokenOffsets = {
    [1] = { Vector(0, 3, -0.2) },
    [2] = { Vector(0.4, 3, -0.2), Vector(-0.4, 3, -0.2) },
    [3] = { Vector(0, 3, -0.9), Vector(0.4, 3, -0.2), Vector(-0.4, 3, -0.2) },
    [4] = { Vector(0.4, 3, -0.9), Vector(-0.4, 3, -0.9), Vector(0.4, 3, -0.2), Vector(-0.4, 3, -0.2) }
  }

  -- generate offsets for numTokens > 4 dynamically
  for numTokens = 5, maxTokens do
    local offsets = {}
    local rows = math.min(4, math.ceil(numTokens / 3))
    local tokensPlaced = 0
    for row = 1, rows do
      local y = 3
      local z = -0.9 + (row - 1) * 0.7
      local tokensInRow = math.min(3, numTokens - tokensPlaced)
      for col = 1, tokensInRow do
        local x = 0
        if tokensInRow == 2 then
          x = col == 1 and -0.4 or 0.4
        elseif tokensInRow == 3 then
          x = (col - 2) * 0.7
        end
        table.insert(offsets, Vector(x, y, z))
        tokensPlaced = tokensPlaced + 1
      end
    end
    tokenOffsets[numTokens] = offsets
  end
  return tokenOffsets
end

-- Spawns tokens for the card. This function is built to just throw a card at it and let it do
-- the work once a card has hit an area where it might spawn tokens. It will check to see if
-- the card has already spawned, find appropriate data from either the uses metadata or the Data
-- Helper, and spawn the tokens.
function TokenManager.spawnForCard(params)
  if tokenSpawnTrackerApi.hasSpawnedTokens(params.card.getGUID()) then return end
  local metadata = JSON.decode(params.card.getGMNotes())
  if metadata ~= nil then
    TokenManager.spawnTokensFromUses(params.card, params.extraUses)
  else
    TokenManager.spawnTokensFromDataHelper(params.card)
  end
end

-- Spawns a set of tokens on the given card.
function TokenManager.spawnTokenGroup(params)
  local card       = params.card
  local tokenType  = params.tokenType
  local tokenCount = params.tokenCount
  local replenish  = params.replenish
  local shiftDown  = params.shiftDown
  local subType    = params.subType
  local temporary  = params.temporary

  if tokenType == "damage" or tokenType == "horror" then
    TokenManager.spawnCounterToken(card, tokenType, tokenCount, shiftDown)
  elseif shouldSpawnResourceCounter(tokenType, tokenCount, replenish) then
    TokenManager.spawnResourceCounterToken(card, tokenCount)
  else
    TokenManager.spawnMultipleTokens(card, tokenType, tokenCount, shiftDown, subType, temporary)
  end
end

function shouldSpawnResourceCounter(tokenType, tokenCount, replenish)
  if tokenType == "resource" then
    if optionPanel["useResourceCounters"] == "enabled" then
      return true
    elseif optionPanel["useResourceCounters"] == "custom" then
      -- spawn a resource counter for cards with "0 uses" or small amount of replenshing tokens
      if tokenCount == 0 or (replenish and tokenCount < 3) then
        return true
      end
    end
  end
  return false
end

-- Spawns a single counter token and sets the value to tokenValue. Used for damage and horror tokens.
---@param card tts__Object Card to spawn tokens on
---@param tokenType string Type of token to spawn (template needs to be in source bag)
---@param tokenValue number Value to set the damage/horror to
function TokenManager.spawnCounterToken(card, tokenType, tokenValue, shiftDown)
  TokenManager.spawnToken({
    position = card.positionToWorld(tokenOffsets[1][1] + Vector(0, 0, shiftDown)),
    tokenType = tokenType,
    rotation = card.getRotation(),
    scriptstate = tokenValue
  })
end

function TokenManager.spawnResourceCounterToken(card, tokenValue)
  TokenManager.spawnToken({
    position = card.positionToWorld(card.positionToLocal(card.getPosition()) + Vector(0, 0.2, -0.5)),
    tokenType = "resourceCounter",
    rotation = card.getRotation(),
    scriptstate = tokenValue
  })
end

-- Spawns a number of tokens.
---@param tokenType string Type of token to spawn (template needs to be in source bag)
---@param tokenCount number How many tokens to spawn
---@param shiftDown? number An offset for the z-value of this group of tokens
---@param subType? string Subtype of token to spawn. This will only differ from the tokenName for resource or action tokens
---@param temporary? boolean If present adds the temporary tag to an action token
function TokenManager.spawnMultipleTokens(card, tokenType, tokenCount, shiftDown, subType, temporary)
  if tokenCount < 1 then return end

  local offsets = {}
  if tokenType == "clue" then
    offsets = TokenManager.buildClueOffsets(card, tokenCount)
  else
    if tokenCount > 12 then
      printToAll("Attempting to spawn " .. tokenCount .. " tokens. Spawning clickable counter instead.")
      TokenManager.spawnResourceCounterToken(card, tokenCount)
      return
    end
    for i = 1, tokenCount do
      -- if spawning action tokens, increase offsets slightly since they are larger
      if tokenType == "universalActionAbility" then
        offsets[i] = card.positionToWorld(tokenOffsets[tokenCount][i] * Vector(1.2, 1, 1.2))
      else
        offsets[i] = card.positionToWorld(tokenOffsets[tokenCount][i])
      end

      -- make sure tokens on face down cards spawn on the "up" side
      if card.is_face_down then
        offsets[i] = offsets[i] + Vector(0, 0.3, 0)
      end
    end
  end

  if shiftDown ~= nil then
    -- Copy the offsets to make sure we don't change the static values
    local baseOffsets = offsets
    offsets = {}

    -- get a vector for the shifting (downwards local to the card)
    local shiftDownVector = Vector(0, 0, shiftDown):rotateOver("y", card.getRotation().y)
    for i, baseOffset in ipairs(baseOffsets) do
      offsets[i] = baseOffset + shiftDownVector
    end
  end

  if offsets == nil then
    error("couldn't find offsets for " .. tokenCount .. ' tokens')
    return
  end

  -- if a special resource exists, spawn it directly
  if stateTable[string.lower(subType or "")] then
    tokenType = string.lower(subType)
  end

  -- special handling for some tokens like action/ability tokens
  local callbackName = nil
  local callbackParams = nil
  if tokenType == "universalActionAbility" then
    local matColor = playermatApi.getMatColorByPosition(card.getPosition())
    local activeInvestigatorData = playermatApi.getActiveInvestigatorData(matColor)
    callbackName = "updateUniversalActionAbilityToken"
    callbackParams = {
      class  = activeInvestigatorData.class,
      symbol = subType
    }
  end

  for i = 1, tokenCount do
    TokenManager.spawnToken({
      position       = offsets[i],
      tokenType      = tokenType,
      rotation       = card.getRotation(),
      callbackName   = callbackName,
      callbackParams = callbackParams,
      addTag         = temporary and "Temporary" or nil
    })
  end
end

-- Spawns a single token at the given global position by copying it from the template bag.
function TokenManager.spawnToken(params)
  local rotation       = params.rotation
  local tokenType      = params.tokenType
  local callbackName   = params.callbackName
  local callbackParams = params.callbackParams
  local scriptstate    = params.scriptstate
  local addTag         = params.addTag
  local spawnData      = { position = params.position }

  -- maybe set callback function
  if callbackName then
    if type(_G[callbackName]) ~= "function" then
      error("Callback function " .. callbackName .. " does not exist")
      return
    else
      spawnData.callback_function = function(obj) _G[callbackName](obj, callbackParams) end
    end
  end

  -- get data for token type
  local loadTokenType = tokenType
  if tokenType == "clue" or tokenType == "doom" then
    loadTokenType = "clueDoom"
  end

  local tokenTemplate = deepCopy(tokenTemplates[loadTokenType])
  if tokenTemplate == nil then
    error("Unknown token type '" .. loadTokenType .. "'")
    return
  end

  tokenTemplate.Nickname = ""
  spawnData.data = tokenTemplate

  -- maybe directly update the script state of the token
  if scriptstate then
    spawnData.data["LuaScriptState"] = tostring(scriptstate)
  end

  -- maybe update tags
  if addTag then
    spawnData.data["Tags"] = spawnData.data["Tags"] or {}
    table.insert(spawnData.data["Tags"], addTag)
    removeDuplicatesAndSort(spawnData.data["Tags"])
  end

  -- get rotation for the token
  -- Take ONLY the Y-value for rotation, so we don't flip the token coming out of the bag
  local rot = Vector(tokenTemplate.Transform.rotX, 270, tokenTemplate.Transform.rotZ)
  if rotation ~= nil then
    rot.y = rotation.y
  end
  if tokenType == "doom" then
    rot.z = 180
  end

  spawnData.rotation = rot

  return spawnObjectData(spawnData)
end

-- Checks a card for metadata to maybe replenish it
function TokenManager.maybeReplenishCard(params)
  for _, useInfo in ipairs(params.uses) do
    if useInfo.count and useInfo.replenish then
      TokenManager.replenishTokens(params.card, useInfo)
    end
  end
end

-- Pushes new player card data into the local copy of the Data Helper player data.
---@param dataTable table Key/Value pairs following the DataHelper style
function TokenManager.addPlayerCardData(dataTable)
  TokenManager.initDataHelperData()
  for k, v in pairs(dataTable) do
    playerCardData[k] = v
  end
end

-- Pushes new location data into the local copy of the Data Helper location data.
---@param dataTable table Key/Value pairs following the DataHelper style
function TokenManager.addLocationData(dataTable)
  TokenManager.initDataHelperData()
  for k, v in pairs(dataTable) do
    locationData[k] = v
  end
end

-- Checks to see if the given card has location data in the DataHelper
---@param card tts__Object Card to check for data
---@return boolean: True if this card has data in the helper, false otherwise
function TokenManager.hasLocationData(card)
  TokenManager.initDataHelperData()
  return TokenManager.getLocationData(card) ~= nil
end

function TokenManager.initTokenTemplates()
  tokenTemplates = {}
  local tokenSource = guidReferenceApi.getObjectByOwnerAndType("Mythos", "TokenSource")
  for _, tokenTemplate in ipairs(tokenSource.getData().ContainedObjects) do
    tokenTemplates[tokenTemplate.Memo] = tokenTemplate
  end

  if tokenTemplates["resource"] ~= nil then
    -- add templates for the resource token states
    for subType, subTypeStateId in pairs(stateTable) do
      if subTypeStateId ~= 1 then
        tokenTemplates[subType] = TokenManager.getTemplateForState(subTypeStateId)
      end
    end
  end
end

-- Copies the data from the DataHelper. Will only happen once.
function TokenManager.initDataHelperData()
  if playerCardData ~= nil then return end
  local dataHelper = guidReferenceApi.getObjectByOwnerAndType("Mythos", "DataHelper")
  playerCardData   = dataHelper.getTable('PLAYER_CARD_DATA')
  locationData     = dataHelper.getTable('LOCATIONS_DATA')
end

-- Spawn tokens for a card based on the uses metadata. This will consider the face up/down state
-- of the card for both locations and standard cards.
---@param card tts__Object Card to maybe spawn tokens for
---@param extraUses table A table of <use type>=<count> which will modify the number of tokens
---    spawned for that type. e.g. Akachi's playermat should pass "Charge"=1
function TokenManager.spawnTokensFromUses(card, extraUses)
  local uses = TokenManager.getUses(card)
  if uses == nil then return end

  card.resting = true

  -- go through tokens to spawn
  local tokenCount
  for i, useInfo in ipairs(uses) do
    tokenCount = (useInfo.count or 0) + (useInfo.countPerInvestigator or 0) * playAreaApi.getInvestigatorCount()
    if extraUses ~= nil and extraUses[useInfo.type] ~= nil then
      tokenCount = tokenCount + extraUses[useInfo.type]
    end
    -- Shift each spawned group after the first down so they don't pile on each other
    TokenManager.spawnTokenGroup({
      card       = card,
      tokenType  = useInfo.token,
      tokenCount = tokenCount,
      replenish  = useInfo.replenish,
      shiftDown  = (i - 1) * 0.8,
      subType    = useInfo.type
    })
  end

  tokenSpawnTrackerApi.markTokensSpawned(card.getGUID())
end

-- Spawn tokens for a card based on the data helper data. This will consider the face up/down state
-- of the card for both locations and standard cards.
---@param card tts__Object Card to maybe spawn tokens for
function TokenManager.spawnTokensFromDataHelper(card)
  TokenManager.initDataHelperData()
  local playerData = TokenManager.getPlayerCardData(card)
  if playerData ~= nil then
    card.resting = true
    TokenManager.spawnPlayerCardTokensFromDataHelper(card, playerData)
  end
  local specificLocationData = TokenManager.getLocationData(card)
  if specificLocationData ~= nil then
    card.resting = true
    TokenManager.spawnLocationTokensFromDataHelper(card, specificLocationData)
  end
end

-- Spawn tokens for a player card using data retrieved from the Data Helper.
---@param card tts__Object Card to maybe spawn tokens for
---@param playerData table Player card data structure retrieved from the DataHelper. Should be
--     the right data for this card.
function TokenManager.spawnPlayerCardTokensFromDataHelper(card, playerData)
  TokenManager.spawnTokenGroup({
    card       = card,
    tokenType  = playerData.tokenType,
    tokenCount = playerData.tokenCount
  })
  tokenSpawnTrackerApi.markTokensSpawned(card.getGUID())
end

-- Spawn tokens for a location using data retrieved from the Data Helper.
---@param card tts__Object Card to maybe spawn tokens for
---@param locationData table Location data structure retrieved from the DataHelper. Should be
--     the right data for this card.
function TokenManager.spawnLocationTokensFromDataHelper(card, locationData)
  local clueCount = TokenManager.getClueCountFromData(card, locationData)
  if clueCount > 0 then
    TokenManager.spawnTokenGroup({
      card       = card,
      tokenType  = "clue",
      tokenCount = clueCount
    })
    tokenSpawnTrackerApi.markTokensSpawned(card.getGUID())
  end
end

function TokenManager.getPlayerCardData(card)
  return playerCardData[card.getName() .. ':' .. card.getDescription()]
      or playerCardData[card.getName()]
end

function TokenManager.getLocationData(card)
  return locationData[card.getName() .. '_' .. card.getGUID()] or locationData[card.getName()]
end

function TokenManager.getClueCountFromData(card, locationData)
  -- Return the number of clues to spawn on this location
  if locationData == nil then
    error('attempted to get clue for unexpected object: ' .. card.getName())
    return 0
  end

  if ((card.is_face_down and locationData.clueSide == 'back')
        or (not card.is_face_down and locationData.clueSide == 'front')) then
    if locationData.type == 'fixed' then
      return locationData.value
    elseif locationData.type == 'perPlayer' then
      return locationData.value * playAreaApi.getInvestigatorCount()
    end
    error('unexpected location type: ' .. locationData.type)
  end
  return 0
end

-- Gets the right uses structure for this card, based on metadata and face up/down state
---@param card tts__Object Card to pull the uses from
TokenManager.getUses = function(card)
  local metadata = JSON.decode(card.getGMNotes()) or {}
  if metadata.type == "Location" then
    if card.is_face_down and metadata.locationBack ~= nil then
      return metadata.locationBack.uses
    elseif not card.is_face_down and metadata.locationFront ~= nil then
      return metadata.locationFront.uses
    end
  elseif not card.is_face_down then
    return metadata.uses
  end
  return nil
end

-- Dynamically create positions for clues on a card
---@param card tts__Object Card the clues will be placed on
---@param count number How many clues?
---@return table: Array of global positions to spawn the clues at
TokenManager.buildClueOffsets = function(card, count)
  -- make sure clues always spawn from left to right
  local modifier = card.is_face_down and 1 or -1

  local cluePositions = {}
  for i = 1, count do
    -- get the set number (1 for clue 1-16, 2 for 17-32 etc.)
    local set = math.floor((i - 1) / 16) + 1

    -- get the local index (always number from 1-16)
    local localIndex = (i - 1) % 16

    -- get row and column for this clue
    local row = math.floor(localIndex / 4) + 1
    local column = localIndex % 4

    -- calculate local position
    local localPos = Vector((-0.825 + 0.55 * column) * modifier, 0, -1.5 + 0.55 * row)

    -- get the global clue position (higher y-position for each set)
    local cluePos = card.positionToWorld(localPos) + Vector(0, 0.03 + 0.103 * (set - 1), 0)

    -- add position to table
    table.insert(cluePositions, cluePos)
  end
  return cluePositions
end

---@param card tts__Object Card object to be replenished
---@param useInfo table The already decoded subtable of metadata.uses (to avoid decoding again)
function TokenManager.replenishTokens(card, useInfo)
  -- get current amount of matching resource tokens on the card
  local clickableResourceCounter = nil
  local foundTokens = 0

  -- we're only searching 80% of the cards area to avoid matching tokens on other cards
  -- (except for clues, since these are on locations and they should never be this close)
  local maybeDeleteThese = {}
  if useInfo.token == "clue" then
    for _, obj in ipairs(searchLib.onObject(card, "isClue")) do
      foundTokens = foundTokens + math.abs(obj.getQuantity())
      table.insert(maybeDeleteThese, obj)
    end
  elseif useInfo.token == "doom" then
    for _, obj in ipairs(searchLib.onObject(card, "isDoom", 0.8)) do
      if not obj.hasTag("DoomCounter_ignore") then
        foundTokens = foundTokens + math.abs(obj.getQuantity())
        table.insert(maybeDeleteThese, obj)
      end
    end
  else
    -- search for the token instead if there's no special resource state for it
    local searchType = string.lower(useInfo.type)
    if stateTable[searchType] == nil then
      searchType = useInfo.token
    end

    for _, obj in ipairs(searchLib.onObject(card, "isTileOrToken", 0.8)) do
      local memo = obj.getMemo()
      if searchType == memo then
        foundTokens = foundTokens + math.abs(obj.getQuantity())
        table.insert(maybeDeleteThese, obj)
      elseif memo == "resourceCounter" then
        foundTokens = obj.getVar("val")
        clickableResourceCounter = obj
        break
      end
    end
  end

  -- this is the theoretical new amount of uses (to be checked below)
  local newCount = foundTokens + useInfo.replenish

  -- if there are already more uses than the replenish amount, keep them
  if foundTokens > useInfo.count then
    newCount = foundTokens
    -- only replenish up until the replenish amount
  elseif newCount > useInfo.count then
    newCount = useInfo.count
  end

  -- update the clickable counter or spawn a group of tokens
  if clickableResourceCounter then
    clickableResourceCounter.call("updateVal", newCount)
  else
    -- delete existing tokens
    for _, obj in ipairs(maybeDeleteThese) do
      obj.destruct()
    end

    -- spawn new token group
    TokenManager.spawnTokenGroup({
      card       = card,
      tokenType  = useInfo.token,
      tokenCount = newCount,
      subType    = useInfo.type
    })
  end
end

-- adds a use to a card
function TokenManager.addUseToCard(params)
  local card = params.card
  local useType = params.useType
  local additionalCount = params.additionalCount or 1

  -- only allow 1 trigger per 5 frame for the same card
  if lastCard == card then return false end
  lastCard = card
  Wait.frames(function() lastCard = nil end, 5)

  local metadata = JSON.decode(card.getGMNotes()) or {}

  -- get correct data for location
  if metadata.type == "Location" then
    if not card.is_face_down and metadata.locationFront ~= nil then
      metadata = metadata.locationFront
    elseif metadata.locationBack ~= nil then
      metadata = metadata.locationBack
    end

    -- if there are no uses at all, add "empty" uses for fake replenishing (only for clues)
    if metadata.uses == nil then
      metadata.uses = { { token = "clue" } }
    end
  end

  -- if there are no uses at all, add "empty" uses for fake replenishing on other cards for doom only
  if params.useType == "doom" and metadata.uses == nil then
    metadata.uses = { { token = "doom" } }
  end

  local match = false
  for _, useInfo in ipairs(metadata.uses or {}) do
    if useInfo.token == useType then
      -- artificially create replenish data to re-use that existing functionality
      useInfo.count = 999
      useInfo.replenish = additionalCount
      match = true
    else
      -- artificially disable other uses from replenishing
      useInfo.replenish = nil
    end
  end

  -- if matching uses were found, perform the "fake" replenish
  if match then
    TokenManager.maybeReplenishCard({ card = card, uses = metadata.uses })
    return true
  else
    return false
  end
end

-- generates the data to spawn an infinite bag of a specific type of resources
function TokenManager.getDataForInfiniteBag(params)
  local tokenTemplate = tokenTemplates[params.tokenType]
  if tokenTemplate == nil then
    error("Unknown token type '" .. params.tokenType .. "'")
    return
  end

  -- generate and return data for the infinite bag
  local properTypeName = params.tokenType:gsub("^%l", string.upper)
  return {
    Name = "Infinite_Bag",
    Nickname = properTypeName .. " Bag",
    ContainedObjects = { tokenTemplate },
    Transform = {
      posX = params.position.x,
      posY = params.position.y,
      posZ = params.position.z,
      rotX = params.rotation.x,
      rotY = params.rotation.y,
      rotZ = params.rotation.z,
      scaleX = 1,
      scaleY = 1,
      scaleZ = 1
    }
  }
end

-- gets the data for a specific resource token state
function TokenManager.getTemplateForState(subTypeStateId)
  -- create a copy of the resource token (to not modify the source)
  local template = deepCopy(tokenTemplates["resource"])
  local subTypeData = template["States"][subTypeStateId]

  -- add states to data
  subTypeData["States"] = template["States"]

  -- add "1" state and remove the current state
  subTypeData["States"][1] = template
  subTypeData["States"][1]["States"] = nil
  subTypeData["States"][subTypeStateId] = nil

  -- update rotation of the main state
  subTypeData["Transform"].rotX = 0
  subTypeData["Transform"].rotY = 0
  subTypeData["Transform"].rotZ = 0

  return subTypeData
end

---------------------------------------------------------
-- Callback functions for token spawning
---------------------------------------------------------

function updateUniversalActionAbilityToken(obj, params)
  obj.call("updateClassAndSymbol", params)
end

function updateStateToken(obj, stateID)
  if stateID ~= nil and stateID ~= 1 then
    obj.setState(stateID)
  end
end

---------------------------------------------------------
-- Utility functions
---------------------------------------------------------

-- allows calling a function inside of a table (like the TokenManager)
function callTable(params)
  local keys = params[1] or {}
  local arg = params[2] or nil
  local var = _G
  for _, key in ipairs(keys) do
    var = var[key]
    if type(var) ~= "table" then break end
  end
  if type(var) ~= "function" then
    log("resulting var was not a function " .. table.concat(keys, "->"))
    return
  end
  return var(arg)
end

-- removes a value from a table
---@return boolean: True if something was removed
function removeValueFromTable(t, val)
  for i, v in ipairs(t) do
    if v == val then
      table.remove(t, i)
      return true
    end
  end
  return false
end

-- checks if a table is empty
function isTableEmpty(tbl)
  if next(tbl) == nil then
    return true
  else
    return false
  end
end

-- returns the colored steam name, investigator name or color
---@param playerColor string Color of the player
function getColoredName(playerColor)
  local displayName = playerColor
  if playerColor ~= "Grey" and Player[playerColor].steam_name then
    displayName = Player[playerColor].steam_name
  else
    local matColor = playermatApi.getMatColor(playerColor)
    local investigatorName = playermatApi.getInvestigatorName(matColor)
    if investigatorName ~= "" then
      displayName = investigatorName
    end
  end

  -- add bb-code
  return "[" .. Color.fromString(playerColor):toHex() .. "]" .. displayName .. "[-]"
end

-- creates a deep copy of a table
function deepCopy(data)
  if type(data) ~= "table" then return data end
  local copiedList = {}
  for key, value in pairs(data) do
    if type(value) == "table" then
      copiedList[key] = deepCopy(value)
    else
      copiedList[key] = value
    end
  end
  return copiedList
end

function removeDuplicatesAndSort(t)
  local seen = {}
  local result = {}

  for _, value in ipairs(t) do
    if not seen[value] then
      seen[value] = true
      table.insert(result, value)
    end
  end

  table.sort(result)

  return result
end

-- wrapper for 'easier' access to this function
-- Note: There's intentionally no proper UI or button etc. for this, since we don't fully support rotated mats
function moveAndRotatePlayermat(params)
  playermatApi.moveAndRotate(params.matColor, params.position, params.rotationY)
end

function handleTokenAttaching(params)
  local card = params.card
  if card == nil then return end

  local player         = params.player
  local searchResult   = searchLib.onObject(card, "isTileOrToken", 0.9)
  local cardPos        = card.getPosition()
  local eligibleTokens = {}
  for _, token in ipairs(searchResult) do
    if not token.locked and token.getPosition().y > (cardPos.y + 0.01) then
      table.insert(eligibleTokens, token)
    end
  end

  if #eligibleTokens == 0 then return end

  -- maybe change settings (and save them to restore later)
  if card.is_face_down then
    cardSettings[card]       = {
      hideFacedown = card.hide_when_face_down,
      tooltip      = card.tooltip
    }
    card.hide_when_face_down = false
    card.tooltip             = false
  end

  for _, token in ipairs(eligibleTokens) do
    card.addAttachment(token)
  end

  Wait.condition(
    function() handleTokenDetaching({ card = card }) end,
    function()
      if card ~= nil and player ~= nil and player.seated then
        return card.resting and card.held_by_color ~= player.color
      else
        return true
      end
    end
  )
end

function handleTokenDetaching(params)
  local card = params.card
  if card == nil or next(card.getAttachments()) == nil then return end

  -- restore card settings
  if cardSettings[card] ~= nil then
    card.hide_when_face_down = cardSettings[card]["hideFacedown"]
    card.tooltip             = cardSettings[card]["tooltip"]
    cardSettings[card]       = nil
  end

  local cardPosition = card.getPosition()

  -- remove attachments (move tokens below the card on top)
  local removedTokens = card.removeAttachments()
  for _, token in ipairs(removedTokens) do
    if token.getPosition().y < cardPosition.y then
      local posY = cardPosition.y + 0.05
      token.setPosition(token.getPosition():setAt("y", posY))
    end
  end

  -- trigger playarea connections
  local locked = card.getLock()
  card.setLock(not locked)
  Wait.frames(function() card.setLock(locked) end, 1)

  -- redraw token xml for cards with sealing
  if card.hasTag("CardThatSeals") then
    local func = card.getVar("updateStackSize") -- make sure function exists
    if func ~= nil then
      card.call("updateStackSize")
    end
  end

  return removedTokens
end

function moveCardWithTokens(params)
  local card     = params.card
  local position = params.position
  local rotation = params.rotation

  stopTokenTransformUpdating(card)
  storeTokenTransform(card)

  if rotation then
    card.setRotation(rotation)
  end

  if position then
    card.use_hands = false
    card.setPositionSmooth(position)
  end

  if #cardTokens[card] == 0 then return end

  -- wait for the card to finish moving, update token position/rotation regularly
  Wait.condition(
    function() stopTokenTransformUpdating(card) end,
    function()
      if card ~= nil and cardTokens[card] ~= nil and #cardTokens[card] ~= 0 then
        updateTokenTransform(card)
        return card.resting and not card.isSmoothMoving()
      end
      return true
    end
  )
end

function storeTokenTransform(card)
  cardTokens[card] = {}
  local cardRot = card.getRotation()
  for _, token in ipairs(searchLib.onObject(card, "isTileOrToken", 0.95)) do
    if not token.locked then
      -- offset to stop the token from colliding with the card
      local tokenPos = token.getPosition() + Vector(0, 0.05, 0)
      token.setPosition(tokenPos)

      -- store local transform data
      table.insert(cardTokens[card], {
        token = token,
        localPos = card.positionToLocal(tokenPos),
        localRot = token.getRotation() - cardRot
      })
    end
  end
end

function updateTokenTransform(card)
  for _, tokenData in ipairs(cardTokens[card] or {}) do
    if tokenData.token ~= nil then
      tokenData.token.setPosition(card.positionToWorld(tokenData.localPos))
      tokenData.token.setRotation(card.getRotation() + tokenData.localRot)
      tokenData.token.locked = true
    end
  end
end

function stopTokenTransformUpdating(card)
  if cardTokens[card] == nil then return end
  for _, tokenData in ipairs(cardTokens[card] or {}) do
    if tokenData.token ~= nil then
      tokenData.token.locked = false
    end
  end
  cardTokens[card] = nil
  if card ~= nil then
    card.use_hands = true
  end
end

-- readies a card respective to its owner
---@param params table Parameters for the function:
--- card tts__Object Card to ready
--- ownerRotation? tts__Vector Rotation of the owner
--- smooth? boolean Should the card be rotated smoothly?
function maybeReadyCard(params)
  local card          = params.card
  local ownerRotation = params.ownerRotation
  local smooth        = params.smooth

  if card.getVar("do_not_ready") or card.hasTag("DoNotReady") then return end

  -- if not provided, get the rotation of the owner
  if not ownerRotation then
    local owner = guidReferenceApi.getOwnerOfObject(card)
    if owner == "Mythos" then
      ownerRotation = playAreaApi.returnRotation()
    else
      ownerRotation = playermatApi.returnRotation(owner)
    end
  end

  local cardRotation = card.getRotation()
  local roundedRotY  = round(cardRotation.y, 0)
  local yRotDiff     = roundedRotY - ownerRotation.y

  if yRotDiff < 0 then
    yRotDiff = yRotDiff + 360
  end

  -- rotate cards to the next multiple of 90° towards 0°
  local cardRotY = ownerRotation.y
  if yRotDiff > 90 and yRotDiff <= 180 then
    cardRotY = ownerRotation.y + 90
  elseif yRotDiff > 180 and yRotDiff < 270 then
    cardRotY = ownerRotation.y + 270
  end

  -- optionally use a smooth rotation
  if smooth then
    card.setRotationSmooth(cardRotation:setAt("y", cardRotY))
  else
    card.setRotation(cardRotation:setAt("y", cardRotY))
  end

  -- returns whether the card is now fully readied (and wasn't ready before)
  if cardRotY == ownerRotation.y and roundedRotY ~= ownerRotation.y then
    return true
  else
    return false
  end
end

-- removes tokens from the provided card/deck
function removeTokensFromObject(params)
  local object = params.object
  if object == nil then return end

  local trash = guidReferenceApi.getObjectByOwnerAndType(params.owner, "Trash")

  if object.hasTag("CardThatSeals") then
    local func = object.getVar("resetSealedTokens") -- check if function exists (it won't for older custom content)
    if func ~= nil then
      object.call("resetSealedTokens")
    end
  end

  if cardTokens[object] then
    -- check if this card was moved with tokens on it
    for _, tokenData in ipairs(cardTokens[object]) do
      if tokenData.token ~= nil then
        tokenData.token.locked = false
        if tokenChecker.isChaosToken(tokenData.token) then
          returnChaosTokenToBag({ token = tokenData.token, fromBag = false })
        else
          trash.putObject(tokenData.token)
        end
      end
    end
    cardTokens[object] = nil
  else
    -- search area for tokens
    for _, obj in ipairs(searchLib.onObject(object, "isTileOrToken")) do
      if tokenChecker.isChaosToken(obj) then
        returnChaosTokenToBag({ token = obj, fromBag = false })
      elseif obj.memo ~= nil and
          obj.getLock() == false and
          obj.interactable == true then
        trash.putObject(obj)
      end
    end
  end
end

function coWaitFrames(frameCount)
  for k = 1, frameCount do
    coroutine.yield(0)
  end
end

-- rounds a number (num) to the Nth decimal (dec)
function round(num, dec)
  local mult = 10 ^ (dec or 0)
  return math.floor(num * mult + 0.5) / mult
end
